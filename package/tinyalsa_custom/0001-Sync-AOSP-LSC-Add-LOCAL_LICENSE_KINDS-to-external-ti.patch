From 30342246908107c22b736afef7c03b5a23edeecb Mon Sep 17 00:00:00 2001
From: dvdli <dvdli@google.com>
Date: Mon, 22 Feb 2021 14:33:57 +0800
Subject: [PATCH] Sync AOSP: [LSC] Add LOCAL_LICENSE_KINDS to
 external/tinyalsa_new

https://android.googlesource.com/platform/external/tinyalsa_new/+/535e6ea3edcb6e119d465073facc3b2a338bdcb1

[LSC] Add LOCAL_LICENSE_KINDS to external/tinyalsa_new

Added SPDX-license-identifier-BSD SPDX-license-identifier-Unlicense to:
  Android.bp

Bug: 68860345
Bug: 151177513
Bug: 151953481

Test: m all

Exempt-From-Owner-Approval: janitorial work
Change-Id: I21fe326f57f35b252901cf1423c4af149694fb51

support float config and float wave file playback

add a loopback test for floating point PCM

add floating-point PCM supoort to tinyplay

This change also fixes overwriting the appl_ptr and avail_min when calling
the pcm_state function.

fix bug in tests

add pcm_prepare before pcm_start

refine null parameters checking and add a unit test case

remove range checking in mixer_ctl_set_value

There are some drivers assigning wrong ranges of mixer control's values.
Let ALSA drivers to check whether values are in ranges.

force pcm_open to open device with the non-blocking flag

When a client opens a PCM device whose substreams are all occupied
without the non-blocking flag, the open function would be blocked in
the kernel until the previous opened ones are closed. This would
cause deadlock if they try to hold the same lock. Most of the ALSA
PCM drivers on embedded systems are implemented with the ALSA SOC
framework. Each PCM device has only one substream. This problem would
happen frequently. To force pcm_open to open PCM devices with
non-blocking flag is beneficial to resolve this problem. It returns
the control to clients to try again later.

The reason why we don't call pcm_open with PCM_NONBLOCK is that the
PCM_NONBLOCK also affects the read and write behaviors.

I also add a test case to test whether the pcm_open would be blocked.

tinyalsa: Add sample pcm/mixer plugin and sample sndcardparser

fix the zero fd closing problem

The pcm_hw_close refused to close the zero fd. Add "equal to"
condition and modify the type of fd to int to close the zero fd.

refactoring: add a wave-file parsing function

refactoring and fix typo

fix remaining_data_size is 0 when not playing a wave file

update NOTICE file and format license header

meson: add attributes.h and plugin.h public headers

mixer: fix index underflow when index=0

In mixer_get_ctl_by_name_and_index(), the post-fix decrement
means that the index will be decremented after the comparison, but
before the return, leading to an unsigned integer underflow.

This causes a crash on platforms with -fsanitize=integer enabled.

Fix this by avoiding decrementing index until after the return.

Change-Id: I25a17ced4185bdebd500285bd30b342b16b4ac12

fix strncpy warnings

insert null at end of strncpy target array.

match the varaibles' type for 64-bit compatibility

Since the variables are snd_pcm_uframes_t and snd_pcm_uframes_t is
unsigned long, using unsigned int causes problem when running on a
64-bit binary.

Also fix the branch name of googletest.

add ioctl to read IEC958 data

include time.h before asound.h

Include time.h before asound.h to avoid the following build failure on
musl that was already fixed a long time with
https://github.com/tinyalsa/tinyalsa/commit/c8333f8c7a4e4b9549abeef7530b2cd20a18e537
but reappeared on version 2.0.0:

In file included from ../src/pcm_hw.c:42:
/home/peko/autobuild/instance-1/output-1/host/i586-buildroot-linux-musl/sysroot/usr/include/sound/asound.h:444:18: error: field 'trigger_tstamp' has incomplete type
  444 |  struct timespec trigger_tstamp; /* time when stream was started/stopped/paused */
      |                  ^~~~~~~~~~~~~~

Fixes:
 - http://autobuild.buildroot.org/results/a75e23dc585bd071f4d65face5489ed6ac22edbe

Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>

Fixed bug with main analysis loop

match the boundary type with kernel driver

1. Remove calculation of boundary and retrieve boundary from ALSA
kernel. Also fix type when getting available and advance appl_ptr.
2. Fix avail in pcm_mmap_transfer getting overflow.
3. Fix typo.

mmap support in tinycap

Added mmap (-M option) support to tinycap utility. This is necessary for some hardware to work (e.g. Plugable HDMI capture card with USB ID 1bcf:2c99).

pcm: Propagate error message to the bad_pcm in case of failure

Signed-off-by: Roman Stratiienko <r.stratiienko@gmail.com>

tinyplay: fix playback of 24-bit and 8-bit pcm

The bits-to-format function returned bool, which happened to work
for PCM_FORMAT_S16_LE (0) and PCM_FORMAT_S32_LE (1). However, all
other formats were incorrectly mapped to PCM_FORMAT_S32_LE. Return
enum pcm_format instead.

Support pcm drain ops

Signed-off-by: Guodong Hu <quic_guodhu@quicinc.com>

mixer: add support for pcm device specific mixer controls

Mixer control such as "Playback channel map" can be registered by
multiple pcm device nodes and is distinguished by device in
snd_ctl_elem_id. Add support to get the control handle associated
with mixer ctl name and device number.
Also, introduce API to get the device number associated with specific
mixer_ctl handle.

utils: tinymix: Print device number associated with mixer controls

For mixer controls with same name and different device number, there
is no clarity in tinymix output. Print device number along with
mixer control name to distinguish between mixer controls with
same name.

fix tinymix
---
 Android.bp                                    |  44 ++-
 NOTICE                                        |   2 +-
 WORKSPACE                                     |   2 +-
 examples/plugins/Android.bp                   |  15 +
 examples/plugins/sample_mixer_plugin.c        | 320 +++++++++++++++++
 examples/plugins/sample_pcm_plugin.c          | 332 ++++++++++++++++++
 examples/sndcardparser/Android.bp             |   7 +
 examples/sndcardparser/sample_sndcardparser.c | 270 ++++++++++++++
 include/tinyalsa/meson.build                  |   2 +
 include/tinyalsa/mixer.h                      |   6 +
 include/tinyalsa/pcm.h                        |  16 +-
 include/tinyalsa/plugin.h                     |   5 +-
 src/mixer.c                                   | 149 ++++++--
 src/mixer_hw.c                                |   1 +
 src/mixer_plugin.c                            |   6 +-
 src/pcm.c                                     | 147 ++++----
 src/pcm_hw.c                                  |  24 +-
 src/pcm_plugin.c                              |  23 +-
 tests/include/pcm_test_device.h               |  24 +-
 tests/src/mixer_test.cc                       |  61 +++-
 tests/src/pcm_loopback_test.cc                | 118 ++++---
 tests/src/pcm_test.cc                         |  94 ++++-
 utils/tinycap.1                               |   5 +
 utils/tinycap.c                               |  26 +-
 utils/tinymix.c                               |   9 +-
 utils/tinyplay.c                              | 220 ++++++++----
 utils/tinywavinfo.c                           |   4 +-
 27 files changed, 1667 insertions(+), 265 deletions(-)
 create mode 100644 examples/plugins/Android.bp
 create mode 100644 examples/plugins/sample_mixer_plugin.c
 create mode 100644 examples/plugins/sample_pcm_plugin.c
 create mode 100644 examples/sndcardparser/Android.bp
 create mode 100644 examples/sndcardparser/sample_sndcardparser.c

diff --git a/Android.bp b/Android.bp
index 51025b8..a36a923 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,3 +1,33 @@
+package {
+    default_applicable_licenses: ["external_tinyalsa_new_license"],
+}
+
+// Added automatically by a large-scale-change that took the approach of
+// 'apply every license found to every target'. While this makes sure we respect
+// every license restriction, it may not be entirely correct.
+//
+// e.g. GPL in an MIT project might only apply to the contrib/ directory.
+//
+// Please consider splitting the single license below into multiple licenses,
+// taking care not to lose any license_kind information, and overriding the
+// default license using the 'licenses: [...]' property on targets as needed.
+//
+// For unused files, consider creating a 'fileGroup' with "//visibility:private"
+// to attach the license to, and including a comment whether the files may be
+// used in the current project.
+// See: http://go/android-license-faq
+license {
+    name: "external_tinyalsa_new_license",
+    visibility: [":__subpackages__"],
+    license_kinds: [
+        "SPDX-license-identifier-BSD",
+        "SPDX-license-identifier-Unlicense",
+    ],
+    license_text: [
+        "NOTICE",
+    ],
+}
+
 cc_library {
     name: "libtinyalsav2",
     host_supported: true,
@@ -33,11 +63,17 @@ cc_library {
     },
 }
 
+cc_library_headers {
+    name: "libtinyalsav2_headers",
+    export_include_dirs: ["include"],
+    vendor_available: true,
+}
+
 cc_binary {
     name: "tinyplay2",
     host_supported: true,
     srcs: ["utils/tinyplay.c"],
-    shared_libs: ["libtinyalsav2"],
+    static_libs: ["libtinyalsav2"],
     cflags: ["-Werror"],
     target: {
         darwin: {
@@ -49,20 +85,20 @@ cc_binary {
 cc_binary {
     name: "tinycap2",
     srcs: ["utils/tinycap.c"],
-    shared_libs: ["libtinyalsav2"],
+    static_libs: ["libtinyalsav2"],
     cflags: ["-Werror"],
 }
 
 cc_binary {
     name: "tinymix2",
     srcs: ["utils/tinymix.c"],
-    shared_libs: ["libtinyalsav2"],
+    static_libs: ["libtinyalsav2"],
     cflags: ["-Werror", "-Wall"],
 }
 
 cc_binary {
     name: "tinypcminfo2",
     srcs: ["utils/tinypcminfo.c"],
-    shared_libs: ["libtinyalsav2"],
+    static_libs: ["libtinyalsav2"],
     cflags: ["-Werror"],
 }
diff --git a/NOTICE b/NOTICE
index 5debd99..5e78690 100644
--- a/NOTICE
+++ b/NOTICE
@@ -1,4 +1,5 @@
 Copyright 2011, The Android Open Source Project
+Copyright (c) 2019, The Linux Foundation.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
@@ -22,4 +23,3 @@ CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 DAMAGE.
-
diff --git a/WORKSPACE b/WORKSPACE
index 02b57bf..133cfc5 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -3,5 +3,5 @@ load("@bazel_tools//tools/build_defs/repo:git.bzl", "git_repository")
 git_repository(
     name = "googletest",
     remote = "https://github.com/google/googletest",
-    branch = "master",
+    branch = "main",
 )
diff --git a/examples/plugins/Android.bp b/examples/plugins/Android.bp
new file mode 100644
index 0000000..840480e
--- /dev/null
+++ b/examples/plugins/Android.bp
@@ -0,0 +1,15 @@
+cc_library {
+    name: "libtinyalsav2_example_plugin_pcm",
+    vendor: true,
+    srcs: ["sample_pcm_plugin.c"],
+    cflags: ["-Werror", "-Wno-unused-parameter"],
+    header_libs: ["libtinyalsav2_headers"],
+}
+
+cc_library {
+    name: "libtinyalsav2_example_plugin_mixer",
+    vendor: true,
+    srcs: ["sample_mixer_plugin.c"],
+    cflags: ["-Werror", "-Wno-unused-parameter"],
+    header_libs: ["libtinyalsav2_headers"],
+}
diff --git a/examples/plugins/sample_mixer_plugin.c b/examples/plugins/sample_mixer_plugin.c
new file mode 100644
index 0000000..8ecf56d
--- /dev/null
+++ b/examples/plugins/sample_mixer_plugin.c
@@ -0,0 +1,320 @@
+/* sample_mixer_plugin.c
+**
+** Copyright (c) 2021, The Linux Foundation. All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above
+**     copyright notice, this list of conditions and the following
+**     disclaimer in the documentation and/or other materials provided
+**     with the distribution.
+**   * Neither the name of The Linux Foundation nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+** ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+** IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**/
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sound/asound.h>
+#include <tinyalsa/plugin.h>
+#include <tinyalsa/asoundlib.h>
+
+#define SAMPLE_MIXER_PRIV_GET_CTL_PTR(p, idx) (p->ctls + idx)
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+static const char *const sample_enum_text[] = {"One", "Two", "Three"};
+
+struct sample_mixer_priv {
+    struct snd_control *ctls;
+    int ctl_count;
+
+    struct snd_value_enum sample_enum;
+
+    mixer_event_callback event_cb;
+};
+
+static int sample_mixer_int_ctl_get(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+    return 0;
+}
+
+static int sample_mixer_int_ctl_put(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+/*
+ *   Integer values can be retrieved using:
+ *   uint32_t val1 = (uint32_t)ev->value.integer.value[0];
+ *   uint32_t val2 = (uint32_t)ev->value.integer.value[1];
+ *   uint32_t val3 = (uint32_t)ev->value.integer.value[2];
+ */
+    return 0;
+}
+
+static int sample_mixer_byte_array_ctl_get(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+    return 0;
+}
+
+static int sample_mixer_byte_array_ctl_put(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+/*
+ *   Byte array payload can be retrieved using:
+ *   void *payload = ev->value.bytes.data;
+ */
+
+    return 0;
+}
+
+static int sample_mixer_tlv_ctl_get(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_tlv *ev)
+{
+    return 0;
+}
+
+static int sample_mixer_tlv_ctl_put(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_tlv *tlv)
+{
+/*
+ *   TLV payload and len can be retrieved using:
+ *   void *payload = &tlv->tlv[0];
+ *   size_t tlv_size = tlv->length;
+ */
+
+    return 0;
+}
+
+static int sample_mixer_enum_ctl_get(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+    return 0;
+}
+
+static int sample_mixer_enum_ctl_put(struct mixer_plugin *plugin,
+                struct snd_control *ctl, struct snd_ctl_elem_value *ev)
+{
+/*
+ *    Enum value can be retrieved using:
+ *    unsigned int val = ev->value.enumerated.item[0];
+ */
+    return 0;
+}
+
+static struct snd_value_int sample_mixer_ctl_value_int =
+    SND_VALUE_INTEGER(3, 0, 1000, 100);
+
+/* 512 max bytes for non-tlv byte controls */
+static struct snd_value_bytes byte_array_ctl_bytes =
+    SND_VALUE_BYTES(512);
+
+static struct snd_value_tlv_bytes sample_mixer_tlv_ctl_bytes =
+    SND_VALUE_TLV_BYTES(1024, sample_mixer_tlv_ctl_get, sample_mixer_tlv_ctl_put);
+
+static void create_integer_ctl(struct sample_mixer_priv *priv,
+                int ctl_idx, int pval, void *pdata)
+{
+    struct snd_control *ctl = SAMPLE_MIXER_PRIV_GET_CTL_PTR(priv, ctl_idx);
+    char *ctl_name = strdup("Sample integer control");
+
+    /* pval and pdata can be retrieved using snd_control during get()/put() */
+    INIT_SND_CONTROL_INTEGER(ctl, ctl_name, sample_mixer_int_ctl_get,
+                    sample_mixer_int_ctl_put, sample_mixer_ctl_value_int, pval, pdata);
+}
+
+static void create_byte_array_ctl(struct sample_mixer_priv *priv,
+    int ctl_idx, int pval, void *pdata)
+{
+    struct snd_control *ctl = SAMPLE_MIXER_PRIV_GET_CTL_PTR(priv, ctl_idx);
+    char *ctl_name = strdup("Sample byte array control");
+
+    INIT_SND_CONTROL_BYTES(ctl, ctl_name, sample_mixer_byte_array_ctl_get,
+            sample_mixer_byte_array_ctl_put, byte_array_ctl_bytes,
+            pval, pdata);
+}
+
+static void create_tlv_ctl(struct sample_mixer_priv *priv,
+                int ctl_idx, int pval, void *pdata)
+{
+    struct snd_control *ctl = SAMPLE_MIXER_PRIV_GET_CTL_PTR(priv, ctl_idx);
+    char *ctl_name = strdup("Sample tlv control");
+
+    INIT_SND_CONTROL_TLV_BYTES(ctl, ctl_name, sample_mixer_tlv_ctl_bytes,
+                    pval, pdata);
+}
+
+static void create_enum_ctl(struct sample_mixer_priv *priv,
+            int ctl_idx, struct snd_value_enum *e,
+            int pval, void *pdata)
+{
+    struct snd_control *ctl = SAMPLE_MIXER_PRIV_GET_CTL_PTR(priv, ctl_idx);
+    char *ctl_name = strdup("Sample enum control");
+
+    INIT_SND_CONTROL_ENUM(ctl, ctl_name, sample_mixer_enum_ctl_get,
+                    sample_mixer_enum_ctl_put, e, pval, pdata);
+}
+
+static int sample_mixer_form_ctls(struct sample_mixer_priv *priv, int ctl_idx)
+{
+    create_integer_ctl(priv, ctl_idx, 0, NULL);
+    ctl_idx++;
+    create_byte_array_ctl(priv, ctl_idx, 0, NULL);
+    ctl_idx++;
+    create_tlv_ctl(priv, ctl_idx, 0, NULL);
+    ctl_idx++;
+    create_enum_ctl(priv, ctl_idx, &priv->sample_enum, 0, NULL);
+    ctl_idx++;
+
+    return 0;
+}
+
+static ssize_t sample_mixer_read_event(struct mixer_plugin *plugin,
+                              struct snd_ctl_event *ev, size_t size)
+{
+    /* Fill snd_ctl_event *ev before sending.
+     * Return : sizeof(struct snd_ctl_event),
+     *          0 in case no event present.
+     */
+
+    return 0;
+}
+
+static int sample_mixer_subscribe_events(struct mixer_plugin *plugin,
+                                  mixer_event_callback event_cb)
+{
+    struct sample_mixer_priv *priv = plugin->priv;
+
+    priv->event_cb = event_cb;
+   /* event_cb is the callback function which needs to be called
+    * when an event occurs. This will unblock poll() on mixer fd
+    * which is called from mixer_wait_event().
+    * Once poll is unblocked, clients can call mixer_read_event()
+    * During unsubscribe(), event_cb is NULL.
+    */
+    return 0;
+}
+
+static int sample_mixer_alloc_ctls(struct sample_mixer_priv *priv)
+{
+    int ret = 0, i;
+
+    priv->ctls = calloc(priv->ctl_count, sizeof(*priv->ctls));
+    if (!priv->ctls) {
+        return -ENOMEM;
+    }
+
+    priv->sample_enum.items = ARRAY_SIZE(sample_enum_text);
+    priv->sample_enum.texts = calloc(priv->sample_enum.items, sizeof(*priv->sample_enum.texts));
+
+    for (i = 0; i < ARRAY_SIZE(sample_enum_text); i++)
+        priv->sample_enum.texts[i] = strdup(sample_enum_text[i]);
+
+    return sample_mixer_form_ctls(priv, 0);
+}
+
+static void sample_mixer_free_ctls(struct sample_mixer_priv *priv)
+{
+    int num_enums, i;
+    struct snd_control *ctl = NULL;
+
+    for (i = 0; i < priv->ctl_count; i++) {
+        ctl = SAMPLE_MIXER_PRIV_GET_CTL_PTR(priv, i);
+        if (ctl->name)
+            free((void *)ctl->name);
+    }
+
+    num_enums = priv->sample_enum.items;
+
+    for (i = 0; i < num_enums; i++)
+        free(priv->sample_enum.texts[i]);
+
+    free(priv->sample_enum.texts);
+    priv->ctl_count = 0;
+
+    if (priv->ctls) {
+        free(priv->ctls);
+        priv->ctls = NULL;
+    }
+}
+
+static void sample_mixer_close(struct mixer_plugin **plugin)
+{
+    struct mixer_plugin *mp = *plugin;
+    struct sample_mixer_priv *priv = mp->priv;
+
+    /* unblock mixer event during close */
+    if (priv->event_cb)
+        priv->event_cb(mp);
+    sample_mixer_subscribe_events(mp, NULL);
+    sample_mixer_free_ctls(priv);
+    free(priv);
+    free(*plugin);
+    *plugin = NULL;
+}
+
+int sample_mixer_open(struct mixer_plugin **plugin, unsigned int card)
+{
+    struct mixer_plugin *mp;
+    struct sample_mixer_priv *priv;
+    int i, ret = 0;
+    int ctl_cnt = 4;
+
+    mp = calloc(1, sizeof(*mp));
+    if (!mp) {
+        return -ENOMEM;
+    }
+
+    priv = calloc(1, sizeof(*priv));
+    if (!priv) {
+        ret = -ENOMEM;
+        goto err_priv_alloc;
+    }
+
+    priv->ctl_count = ctl_cnt;
+    ret = sample_mixer_alloc_ctls(priv);
+    if (ret)
+        goto err_ctls_alloc;
+
+    /* Register the controls */
+    mp->controls = priv->ctls;
+    mp->num_controls = priv->ctl_count;
+    mp->priv = priv;
+    *plugin = mp;
+
+    return 0;
+
+err_ctls_alloc:
+    sample_mixer_free_ctls(priv);
+    free(priv);
+
+err_priv_alloc:
+    free(mp);
+    return ret;
+}
+
+struct mixer_plugin_ops mixer_plugin_ops = {
+    .open = sample_mixer_open,
+    .close = sample_mixer_close,
+    .subscribe_events = sample_mixer_subscribe_events,
+    .read_event = sample_mixer_read_event,
+};
diff --git a/examples/plugins/sample_pcm_plugin.c b/examples/plugins/sample_pcm_plugin.c
new file mode 100644
index 0000000..40bf684
--- /dev/null
+++ b/examples/plugins/sample_pcm_plugin.c
@@ -0,0 +1,332 @@
+/* sample_mixer_plugin.c
+**
+** Copyright (c) 2021, The Linux Foundation. All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above
+**     copyright notice, this list of conditions and the following
+**     disclaimer in the documentation and/or other materials provided
+**     with the distribution.
+**   * Neither the name of The Linux Foundation nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+** ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+** IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**/
+
+#include <errno.h>
+#include <limits.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <sound/asound.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <tinyalsa/plugin.h>
+#include <tinyalsa/asoundlib.h>
+
+/* 2 words of uint32_t = 64 bits of mask */
+#define PCM_MASK_SIZE (2)
+#define PCM_FORMAT_BIT(x) (1ULL << x)
+
+struct sample_pcm_priv {
+    FILE *fptr;
+    int session_id;
+    int channels;
+    int bitwidth;
+    int sample_rate;
+    unsigned int period_size;
+    snd_pcm_uframes_t total_size_frames;
+};
+
+struct pcm_plugin_hw_constraints sample_pcm_constrs = {
+    .access = 0,
+    .format = 0,
+    .bit_width = {
+        .min = 16,
+        .max = 32,
+    },
+    .channels = {
+        .min = 1,
+        .max = 8,
+    },
+    .rate = {
+        .min = 8000,
+        .max = 384000,
+    },
+    .periods = {
+        .min = 1,
+        .max = 8,
+    },
+    .period_bytes = {
+        .min = 96,
+        .max = 122880,
+    },
+};
+
+static inline struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p,
+                                                  int n)
+{
+    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+}
+
+static inline int param_is_interval(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+}
+
+static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        if (i->integer)
+            return i->max;
+    }
+    return 0;
+}
+
+static inline struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+}
+
+static inline int param_is_mask(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+}
+
+static inline int snd_mask_val(const struct snd_mask *mask)
+{
+    int i;
+    for (i = 0; i < PCM_MASK_SIZE; i++) {
+        if (mask->bits[i])
+            return ffs(mask->bits[i]) + (i << 5) - 1;
+    }
+    return 0;
+}
+
+static int alsaformat_to_bitwidth(int format)
+{
+    switch (format) {
+    case SNDRV_PCM_FORMAT_S32_LE:
+    case SNDRV_PCM_FORMAT_S24_LE:
+        return 32;
+    case SNDRV_PCM_FORMAT_S8:
+        return 8;
+    case SNDRV_PCM_FORMAT_S24_3LE:
+        return 24;
+    default:
+    case SNDRV_PCM_FORMAT_S16_LE:
+        return 16;
+    };
+}
+
+static int param_get_mask_val(struct snd_pcm_hw_params *p,
+                                        int n)
+{
+    if (param_is_mask(n)) {
+        struct snd_mask *m = param_to_mask(p, n);
+        int val = snd_mask_val(m);
+
+        return alsaformat_to_bitwidth(val);
+    }
+    return 0;
+}
+
+static int sample_session_open(int sess_id, unsigned int mode, struct sample_pcm_priv *priv)
+{
+     char fname[128];
+
+     snprintf(fname, 128, "sample_pcm_data_%d.raw", sess_id);
+     priv->fptr = fopen(fname,"rwb+");
+     if (priv->fptr == NULL) {
+         return -EIO;
+     }
+     rewind(priv->fptr);
+     return 0;
+}
+
+
+static int sample_session_write(struct sample_pcm_priv *priv, void *buff, size_t count)
+{
+    uint8_t *data = (uint8_t *)buff;
+    size_t len;
+
+    len  = fwrite(buff, 1, count, priv->fptr);
+
+    if (len != count)
+        return -EIO;
+
+    return 0;
+}
+
+static int sample_pcm_hw_params(struct pcm_plugin *plugin,
+                             struct snd_pcm_hw_params *params)
+{
+    struct sample_pcm_priv *priv = plugin->priv;
+
+    priv->sample_rate = param_get_int(params, SNDRV_PCM_HW_PARAM_RATE);
+    priv->channels = param_get_int(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+    priv->bitwidth = param_get_mask_val(params, SNDRV_PCM_HW_PARAM_FORMAT);
+
+    return 0;
+}
+
+static int sample_pcm_sw_params(struct pcm_plugin *plugin,
+                             struct snd_pcm_sw_params *sparams)
+{
+    return 0;
+}
+
+static int sample_pcm_sync_ptr(struct pcm_plugin *plugin,
+                            struct snd_pcm_sync_ptr *sync_ptr)
+{
+    return 0;
+}
+
+static int sample_pcm_writei_frames(struct pcm_plugin *plugin, struct snd_xferi *x)
+{
+    struct sample_pcm_priv *priv = plugin->priv;
+    void *buff;
+    size_t count;
+
+    buff = x->buf;
+    count = x->frames * (priv->channels * (priv->bitwidth) / 8);
+
+    return sample_session_write(priv, buff, count);
+}
+
+static int sample_pcm_readi_frames(struct pcm_plugin *plugin, struct snd_xferi *x)
+{
+    return 0;
+}
+
+static int sample_pcm_ttstamp(struct pcm_plugin *plugin, int *tstamp)
+{
+    return 0;
+}
+
+static int sample_pcm_prepare(struct pcm_plugin *plugin)
+{
+    return 0;
+}
+
+static int sample_pcm_start(struct pcm_plugin *plugin)
+{
+    return 0;
+}
+
+static int sample_pcm_drop(struct pcm_plugin *plugin)
+{
+    return 0;
+}
+
+static int sample_pcm_close(struct pcm_plugin *plugin)
+{
+    struct sample_pcm_priv *priv = plugin->priv;
+    int ret = 0;
+
+    fclose(priv->fptr);
+    free(plugin->priv);
+    free(plugin);
+
+    return ret;
+}
+
+static int sample_pcm_poll(struct pcm_plugin *plugin, struct pollfd *pfd,
+        nfds_t nfds, int timeout)
+{
+    return 0;
+}
+
+static void* sample_pcm_mmap(struct pcm_plugin *plugin, void *addr, size_t length, int prot,
+                               int flags, off_t offset)
+{
+    return MAP_FAILED;
+}
+
+static int sample_pcm_munmap(struct pcm_plugin *plugin, void *addr, size_t length)
+{
+    return 0;
+}
+
+int sample_pcm_open(struct pcm_plugin **plugin, unsigned int card,
+                    unsigned int device, unsigned int mode)
+{
+    struct pcm_plugin *sample_pcm_plugin;
+    struct sample_pcm_priv *priv;
+    int ret = 0, session_id = device;
+
+    sample_pcm_plugin = calloc(1, sizeof(struct pcm_plugin));
+    if (!sample_pcm_plugin)
+        return -ENOMEM;
+
+    priv = calloc(1, sizeof(struct sample_pcm_priv));
+    if (!priv) {
+        ret = -ENOMEM;
+        goto err_plugin_free;
+    }
+
+    sample_pcm_constrs.access = (PCM_FORMAT_BIT(SNDRV_PCM_ACCESS_RW_INTERLEAVED) |
+                              PCM_FORMAT_BIT(SNDRV_PCM_ACCESS_RW_NONINTERLEAVED));
+    sample_pcm_constrs.format = (PCM_FORMAT_BIT(SNDRV_PCM_FORMAT_S16_LE) |
+                              PCM_FORMAT_BIT(SNDRV_PCM_FORMAT_S24_LE) |
+                              PCM_FORMAT_BIT(SNDRV_PCM_FORMAT_S24_3LE) |
+                              PCM_FORMAT_BIT(SNDRV_PCM_FORMAT_S32_LE));
+
+    sample_pcm_plugin->card = card;
+    sample_pcm_plugin->mode = mode;
+    sample_pcm_plugin->constraints = &sample_pcm_constrs;
+    sample_pcm_plugin->priv = priv;
+
+    priv->session_id = session_id;
+
+    ret = sample_session_open(session_id, mode, priv);
+    if (ret) {
+        errno = -ret;
+        goto err_priv_free;
+    }
+    *plugin = sample_pcm_plugin;
+    return 0;
+
+err_priv_free:
+    free(priv);
+err_plugin_free:
+    free(sample_pcm_plugin);
+    return ret;
+}
+
+struct pcm_plugin_ops pcm_plugin_ops = {
+    .open = sample_pcm_open,
+    .close = sample_pcm_close,
+    .hw_params = sample_pcm_hw_params,
+    .sw_params = sample_pcm_sw_params,
+    .sync_ptr = sample_pcm_sync_ptr,
+    .writei_frames = sample_pcm_writei_frames,
+    .readi_frames = sample_pcm_readi_frames,
+    .ttstamp = sample_pcm_ttstamp,
+    .prepare = sample_pcm_prepare,
+    .start = sample_pcm_start,
+    .drop = sample_pcm_drop,
+    .mmap = sample_pcm_mmap,
+    .munmap = sample_pcm_munmap,
+    .poll = sample_pcm_poll,
+};
diff --git a/examples/sndcardparser/Android.bp b/examples/sndcardparser/Android.bp
new file mode 100644
index 0000000..9ca8812
--- /dev/null
+++ b/examples/sndcardparser/Android.bp
@@ -0,0 +1,7 @@
+cc_library {
+    name: "libsndcardparser_example",
+    vendor: true,
+    srcs: ["sample_sndcardparser.c"],
+    cflags: ["-Werror"],
+}
+
diff --git a/examples/sndcardparser/sample_sndcardparser.c b/examples/sndcardparser/sample_sndcardparser.c
new file mode 100644
index 0000000..b7d7381
--- /dev/null
+++ b/examples/sndcardparser/sample_sndcardparser.c
@@ -0,0 +1,270 @@
+/* sample_sndcardparser.c
+**
+** Copyright (c) 2021, The Linux Foundation. All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above
+**     copyright notice, this list of conditions and the following
+**     disclaimer in the documentation and/or other materials provided
+**     with the distribution.
+**   * Neither the name of The Linux Foundation nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+** ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+** BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+** CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+** SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+** BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+** OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+** IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**/
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+#define VIRTUAL_SND_CARD_ID 100
+#define MAX_PATH 256
+#define BUF_SIZE 1024
+
+enum snd_node_type {
+    NODE_TYPE_HW = 0,
+    NODE_TYPE_PLUGIN,
+    NODE_TYPE_INVALID,
+};
+
+enum {
+    NODE_PCM,
+    NODE_COMPR,
+    NODE_MIXER,
+    NODE_MAX,
+};
+
+struct snd_node_ops {
+    /** Function pointer to get card definition */
+    void* (*open_card)(unsigned int card);
+    /** Function pointer to release card definition */
+    void (*close_card)(void *card);
+    /** Get interger type properties from device definition */
+    int (*get_int)(void *node, const char *prop, int *val);
+    /** Get string type properties from device definition */
+    int (*get_str)(void *node, const char *prop, char **val);
+    /** Function pointer to get mixer definition */
+    void* (*get_mixer)(void *card);
+    /** Function pointer to get PCM definition */
+    void* (*get_pcm)(void *card, unsigned int id);
+    /** Function pointer to get COMPRESS definition */
+    void* (*get_compress)(void *card, unsigned int id);
+};
+
+struct snd_dev_def {
+    unsigned int device;
+    int type;
+    const char *name;
+    const char *so_name;
+    int playback; //used only for pcm node
+    int capture;  //used only for pcm node
+    /* add custom props here */
+};
+
+struct snd_dev_def_card {
+    unsigned int card;
+    char *name;
+
+    /* child device details */
+    int num_pcm_nodes;
+    struct snd_dev_def *pcm_dev_def;
+
+    struct snd_dev_def *mixer_dev_def;
+};
+
+struct snd_dev_def pcm_devs[] = {
+    {100, NODE_TYPE_PLUGIN, "PCM100", "libtinyalsav2_example_plugin_pcm.so", 1, 0},
+    /* Add other plugin info here */
+};
+
+struct snd_dev_def mixer_dev =
+    {VIRTUAL_SND_CARD_ID, NODE_TYPE_PLUGIN, "virtual-snd-card", "libtinyalsav2_example_plugin_mixer.so", 0, 0};
+
+void *snd_card_def_open_card(unsigned int card)
+{
+    struct snd_dev_def_card *card_def = NULL;
+    struct snd_dev_def *pcm_dev_def = NULL;
+    struct snd_dev_def *mixer_dev_def = NULL;
+    int num_pcm = ARRAY_SIZE(pcm_devs);
+    int i;
+
+    if (card != VIRTUAL_SND_CARD_ID)
+        return NULL;
+
+    card_def = calloc(1, sizeof(struct snd_dev_def_card));
+    if (!card_def)
+        return card_def;
+
+    card_def->card = card;
+    card_def->name = strdup("virtual-snd-card");
+
+    /* fill pcm device node info */
+    card_def->num_pcm_nodes = num_pcm;
+    pcm_dev_def = calloc(num_pcm, sizeof(struct snd_dev_def));
+    if (!pcm_dev_def)
+        goto free_card_def;
+
+    for (i = 0; i < num_pcm; i++)
+        memcpy(&pcm_dev_def[i], &pcm_devs[i], sizeof(struct snd_dev_def));
+
+    card_def->pcm_dev_def = pcm_dev_def;
+
+    /* fill mixer device node info */
+    mixer_dev_def = calloc(1, sizeof(struct snd_dev_def));
+    if (!mixer_dev_def)
+        goto free_pcm_dev;
+
+    memcpy(mixer_dev_def, &mixer_dev, sizeof(struct snd_dev_def));
+
+    card_def->mixer_dev_def = mixer_dev_def;
+    return card_def;
+free_pcm_dev:
+    free(pcm_dev_def);
+free_card_def:
+    free(card_def->name);
+    free(card_def);
+    return NULL;
+}
+
+void snd_card_def_close_card(void *card_node)
+{
+    struct snd_dev_def_card *defs = (struct snd_dev_def_card *)card_node;
+    struct snd_dev_def *pcm_dev_def = NULL;
+    struct snd_dev_def *mixer_dev_def = NULL;
+
+    if (!defs)
+        return;
+
+    pcm_dev_def = defs->pcm_dev_def;
+    if (pcm_dev_def)
+        free(pcm_dev_def);
+
+    mixer_dev_def = defs->mixer_dev_def;
+    if (!mixer_dev_def)
+         goto free_defs;
+
+    free(mixer_dev_def);
+free_defs:
+    free(defs->name);
+    free(defs);
+}
+
+void *snd_card_def_get_node(void *card_node, unsigned int id, int type)
+{
+    struct snd_dev_def_card *card_def = (struct snd_dev_def_card *)card_node;
+    struct snd_dev_def *dev_def = NULL;
+    int i;
+
+    if (!card_def)
+        return NULL;
+
+    if (type >= NODE_MAX)
+        return NULL;
+
+    if (type == NODE_MIXER)
+        return card_def->mixer_dev_def;
+
+    if (type == NODE_PCM)
+        dev_def = card_def->pcm_dev_def;
+
+    for (i = 0; i < card_def->num_pcm_nodes; i++) {
+        if (dev_def[i].device == id) {
+            return &dev_def[i];
+        }
+    }
+
+    return NULL;
+}
+
+int snd_card_def_get_int(void *node, const char *prop, int *val)
+{
+    struct snd_dev_def *dev_def = (struct snd_dev_def *)node;
+    int ret = -EINVAL;
+
+    if (!dev_def || !prop || !val)
+        return ret;
+
+    if (!strcmp(prop, "type")) {
+        *val = dev_def->type;
+        return 0;
+    } else if (!strcmp(prop, "id")) {
+        *val = dev_def->device;
+        return 0;
+    } else if (!strcmp(prop, "playback")) {
+        *val = dev_def->playback;
+        return 0;
+    } else if (!strcmp(prop, "capture")) {
+        *val = dev_def->capture;
+        return 0;
+    }
+
+    return ret;
+}
+
+int snd_card_def_get_str(void *node, const char *prop, char **val)
+{
+    struct snd_dev_def *dev_def = (struct snd_dev_def *)node;
+    int ret = -EINVAL;
+
+    if (!dev_def || !prop)
+        return ret;
+
+    if (!strcmp(prop, "so-name")) {
+        if (dev_def->so_name) {
+            *val = (char *)dev_def->so_name;
+            return 0;
+        }
+    }
+
+    if (!strcmp(prop, "name")) {
+        if (dev_def->name) {
+            *val = (char *)dev_def->name;
+            return 0;
+        }
+    }
+
+    return ret;
+}
+
+void *snd_card_def_get_pcm(void *card_node, unsigned int id)
+{
+    return snd_card_def_get_node(card_node, id, NODE_PCM);
+}
+
+void *snd_card_def_get_compress(void *card_node, unsigned int id)
+{
+    return snd_card_def_get_node(card_node, id, NODE_COMPR);
+}
+
+void *snd_card_def_get_mixer(void *card_node)
+{
+    return snd_card_def_get_node(card_node, 1, NODE_MIXER);
+}
+
+struct snd_node_ops snd_card_ops = {
+    .open_card = snd_card_def_open_card,
+    .close_card = snd_card_def_close_card,
+    .get_int = snd_card_def_get_int,
+    .get_str = snd_card_def_get_str,
+    .get_pcm = snd_card_def_get_pcm,
+    .get_compress = snd_card_def_get_compress,
+    .get_mixer = snd_card_def_get_mixer,
+};
diff --git a/include/tinyalsa/meson.build b/include/tinyalsa/meson.build
index d14b35b..95077be 100644
--- a/include/tinyalsa/meson.build
+++ b/include/tinyalsa/meson.build
@@ -1,9 +1,11 @@
 tinyalsa_headers = [
   'asoundlib.h',
+  'attributes.h',
   'interval.h',
   'limits.h',
   'mixer.h',
   'pcm.h',
+  'plugin.h',
   'version.h'
 ]
 
diff --git a/include/tinyalsa/mixer.h b/include/tinyalsa/mixer.h
index 7d0580f..149b395 100644
--- a/include/tinyalsa/mixer.h
+++ b/include/tinyalsa/mixer.h
@@ -103,6 +103,10 @@ struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id);
 
 struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name);
 
+struct mixer_ctl *mixer_get_ctl_by_name_and_device(struct mixer *mixer,
+                                                   const char *name,
+                                                   unsigned int device);
+
 struct mixer_ctl *mixer_get_ctl_by_name_and_index(struct mixer *mixer,
                                                   const char *name,
                                                   unsigned int index);
@@ -153,6 +157,8 @@ int mixer_ctl_get_range_min(const struct mixer_ctl *ctl);
 
 int mixer_ctl_get_range_max(const struct mixer_ctl *ctl);
 
+unsigned int mixer_ctl_get_device(const struct mixer_ctl *ctl);
+
 int mixer_read_event(struct mixer *mixer, struct mixer_ctl_event *event);
 
 int mixer_consume_event(struct mixer *mixer);
diff --git a/include/tinyalsa/pcm.h b/include/tinyalsa/pcm.h
index b40550c..35318a5 100644
--- a/include/tinyalsa/pcm.h
+++ b/include/tinyalsa/pcm.h
@@ -178,6 +178,10 @@ enum pcm_format {
     PCM_FORMAT_S24_3BE,
     /** Signed, 32-bit, big endian */
     PCM_FORMAT_S32_BE,
+    /** 32-bit float, little endian */
+    PCM_FORMAT_FLOAT_LE,
+    /** 32-bit float, big endian */
+    PCM_FORMAT_FLOAT_BE,
     /** Max of the enumeration list, not an actual format. */
     PCM_FORMAT_MAX
 };
@@ -213,16 +217,16 @@ struct pcm_config {
      * silence_size      : 0
      */
     /** The minimum number of frames required to start the PCM */
-    unsigned int start_threshold;
+    unsigned long start_threshold;
     /** The minimum number of frames required to stop the PCM */
-    unsigned int stop_threshold;
+    unsigned long stop_threshold;
     /** The minimum number of frames to silence the PCM */
-    unsigned int silence_threshold;
+    unsigned long silence_threshold;
     /** The number of frames to overwrite the playback buffer when the playback underrun is greater
      * than the silence threshold */
-    unsigned int silence_size;
+    unsigned long silence_size;
 
-    unsigned int avail_min;
+    unsigned long avail_min;
 };
 
 /** Enumeration of a PCM's hardware parameters.
@@ -357,6 +361,8 @@ int pcm_prepare(struct pcm *pcm);
 
 int pcm_start(struct pcm *pcm);
 
+int pcm_drain(struct pcm *pcm);
+
 int pcm_stop(struct pcm *pcm);
 
 int pcm_wait(struct pcm *pcm, int timeout);
diff --git a/include/tinyalsa/plugin.h b/include/tinyalsa/plugin.h
index b2f97b9..055734c 100644
--- a/include/tinyalsa/plugin.h
+++ b/include/tinyalsa/plugin.h
@@ -124,7 +124,10 @@ struct pcm_plugin_ops {
     int (*prepare) (struct pcm_plugin *plugin);
     /** Start data transfer from/to the plugin */
     int (*start) (struct pcm_plugin *plugin);
-    /** Drop pcm frames */
+    /** Signal the plugin to drain PCM */
+    int (*drain) (struct pcm_plugin *plugin);
+    /** Stop a PCM dropping pending frames if drain() is NOT called.
+     *  Stop a PCM preserving pending frames if drain() is called. */
     int (*drop) (struct pcm_plugin *plugin);
     /** Any custom or alsa specific ioctl implementation */
     int (*ioctl) (struct pcm_plugin *plugin,
diff --git a/src/mixer.c b/src/mixer.c
index a45502e..f2c21c3 100644
--- a/src/mixer.c
+++ b/src/mixer.c
@@ -55,6 +55,7 @@
 #define __user
 #endif
 
+#include <time.h>
 #include <sound/asound.h>
 
 #include <tinyalsa/mixer.h>
@@ -384,6 +385,10 @@ int mixer_add_new_ctls(struct mixer *mixer)
  */
 const char *mixer_get_name(const struct mixer *mixer)
 {
+    if (!mixer) {
+        return NULL;
+    }
+
     return (const char *)mixer->card_info.name;
 }
 
@@ -413,8 +418,9 @@ unsigned int mixer_get_num_ctls_by_name(const struct mixer *mixer, const char *n
     unsigned int count = 0;
     struct mixer_ctl *ctl;
 
-    if (!mixer)
+    if (!mixer || !name) {
         return 0;
+    }
 
     if (mixer->h_grp) {
         grp = mixer->h_grp;
@@ -449,6 +455,10 @@ int mixer_subscribe_events(struct mixer *mixer, int subscribe)
 {
     struct mixer_ctl_group *grp;
 
+    if (!mixer) {
+        return -EINVAL;
+    }
+
     if (mixer->h_grp) {
         grp = mixer->h_grp;
         if (grp->ops->ioctl(grp->data, SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS, &subscribe) < 0)
@@ -479,6 +489,10 @@ int mixer_wait_event(struct mixer *mixer, int timeout)
     struct mixer_ctl_group *grp;
     int count = 0, num_fds = 0, i, ret = 0;
 
+    if (!mixer) {
+        return -EINVAL;
+    }
+
     if (mixer->fd >= 0)
         num_fds++;
 
@@ -559,6 +573,9 @@ exit:
 int mixer_consume_event(struct mixer *mixer)
 {
     struct mixer_ctl_event ev;
+    if (!mixer) {
+        return -EINVAL;
+    }
 
     return mixer_read_event(mixer, &ev);
 }
@@ -684,6 +701,10 @@ struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id)
  */
 struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name)
 {
+    if (!mixer || !name) {
+        return NULL;
+    }
+
     return mixer_get_ctl_by_name_and_index(mixer, name, 0);
 }
 
@@ -703,17 +724,22 @@ struct mixer_ctl *mixer_get_ctl_by_name_and_index(struct mixer *mixer,
     unsigned int n;
     struct mixer_ctl *ctl;
 
-    if (!mixer)
+    if (!mixer || !name) {
         return NULL;
+    }
 
     if (mixer->h_grp) {
         grp = mixer->h_grp;
         ctl = grp->ctl;
 
         for (n = 0; n < grp->count; n++)
-            if (!strcmp(name, (char*) ctl[n].info.id.name))
-                if (index-- == 0)
+            if (!strcmp(name, (char*) ctl[n].info.id.name)) {
+                if (index == 0) {
                     return ctl + n;
+                } else {
+                    index--;
+                }
+            }
     }
 
 #ifdef TINYALSA_USES_PLUGINS
@@ -722,9 +748,62 @@ struct mixer_ctl *mixer_get_ctl_by_name_and_index(struct mixer *mixer,
         ctl = grp->ctl;
 
         for (n = 0; n < grp->count; n++)
-            if (!strcmp(name, (char*) ctl[n].info.id.name))
-                if (index-- == 0)
+            if (!strcmp(name, (char*) ctl[n].info.id.name)) {
+                if (index == 0) {
                     return ctl + n;
+                } else {
+                    index--;
+                }
+            }
+    }
+#endif
+    return NULL;
+}
+
+/** Gets an instance of mixer control handle, by the mixer control's name and device.
+ *  For instance, if two controls have same name,
+ *  e.g. 'Playback Channel map', then PCM device returns the specific control.
+ * @param mixer An initialized mixer handle.
+ * @param name The control's name in the given mixer.
+ * @param device The PCM device
+ * @returns A handle to the mixer control.
+ * @ingroup libtinyalsa-mixer
+ */
+struct mixer_ctl *mixer_get_ctl_by_name_and_device(struct mixer *mixer,
+                                                   const char *name,
+                                                   unsigned int device)
+{
+    struct mixer_ctl_group *grp;
+    unsigned int n;
+    struct mixer_ctl *ctl;
+
+    if (!mixer || !name) {
+        return NULL;
+    }
+
+    if (mixer->h_grp) {
+        grp = mixer->h_grp;
+        ctl = grp->ctl;
+
+        for (n = 0; n < grp->count; n++) {
+            if (!strcmp(name, (char*) ctl[n].info.id.name) &&
+                    device == ctl[n].info.id.device) {
+                return ctl + n;
+            }
+        }
+    }
+
+#ifdef TINYALSA_USES_PLUGINS
+    if (mixer->v_grp) {
+        grp = mixer->v_grp;
+        ctl = grp->ctl;
+
+        for (n = 0; n < grp->count; n++) {
+            if (!strcmp(name, (char*) ctl[n].info.id.name) &&
+                    device == ctl[n].info.id.device) {
+                return ctl + n;
+            }
+        }
     }
 #endif
     return NULL;
@@ -754,6 +833,10 @@ void mixer_ctl_update(struct mixer_ctl *ctl)
  */
 int mixer_ctl_is_access_tlv_rw(const struct mixer_ctl *ctl)
 {
+    if (!ctl) {
+        return 0;
+    }
+
     return (ctl->info.access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE);
 }
 
@@ -788,6 +871,14 @@ const char *mixer_ctl_get_name(const struct mixer_ctl *ctl)
     return (const char *)ctl->info.id.name;
 }
 
+unsigned int mixer_ctl_get_device(const struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return UINT_MAX;
+
+    return ctl->info.id.device;
+}
+
 /** Gets the value type of the control.
  * @param ctl An initialized control handle
  * @returns On success, the type of mixer control.
@@ -959,8 +1050,9 @@ int mixer_ctl_get_array(const struct mixer_ctl *ctl, void *array, size_t count)
     size_t size;
     void *source;
 
-    if (!ctl || !count || !array)
+    if (!ctl || !array || count == 0) {
         return -EINVAL;
+    }
 
     grp = ctl->grp;
 
@@ -1013,6 +1105,9 @@ int mixer_ctl_get_array(const struct mixer_ctl *ctl, void *array, size_t count)
         }
 
     case SNDRV_CTL_ELEM_TYPE_IEC958:
+        ret = grp->ops->ioctl(grp->data, SNDRV_CTL_IOCTL_ELEM_READ, &ev);
+        if (ret < 0)
+            return ret;
         size = sizeof(ev.value.iec958);
         source = &ev.value.iec958;
         break;
@@ -1042,8 +1137,9 @@ int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value)
     struct snd_ctl_elem_value ev;
     int ret;
 
-    if (!ctl || (id >= ctl->info.count))
+    if (!ctl || id >= ctl->info.count) {
         return -EINVAL;
+    }
 
     grp = ctl->grp;
     memset(&ev, 0, sizeof(ev));
@@ -1058,11 +1154,6 @@ int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value)
         break;
 
     case SNDRV_CTL_ELEM_TYPE_INTEGER:
-        if ((value < mixer_ctl_get_range_min(ctl)) ||
-            (value > mixer_ctl_get_range_max(ctl))) {
-            return -EINVAL;
-        }
-
         ev.value.integer.value[id] = value;
         break;
 
@@ -1098,8 +1189,9 @@ int mixer_ctl_set_array(struct mixer_ctl *ctl, const void *array, size_t count)
     size_t size;
     void *dest;
 
-    if ((!ctl) || !count || !array)
+    if (!ctl || !array || count == 0) {
         return -EINVAL;
+    }
 
     grp = ctl->grp;
 
@@ -1167,8 +1259,9 @@ int mixer_ctl_set_array(struct mixer_ctl *ctl, const void *array, size_t count)
  */
 int mixer_ctl_get_range_min(const struct mixer_ctl *ctl)
 {
-    if (!ctl || (ctl->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+    if (!ctl || ctl->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER) {
         return -EINVAL;
+    }
 
     return ctl->info.value.integer.min;
 }
@@ -1183,8 +1276,9 @@ int mixer_ctl_get_range_min(const struct mixer_ctl *ctl)
  */
 int mixer_ctl_get_range_max(const struct mixer_ctl *ctl)
 {
-    if (!ctl || (ctl->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+    if (!ctl || ctl->info.type != SNDRV_CTL_ELEM_TYPE_INTEGER) {
         return -EINVAL;
+    }
 
     return ctl->info.value.integer.max;
 }
@@ -1196,13 +1290,14 @@ int mixer_ctl_get_range_max(const struct mixer_ctl *ctl)
  */
 unsigned int mixer_ctl_get_num_enums(const struct mixer_ctl *ctl)
 {
-    if (!ctl)
+    if (!ctl) {
         return 0;
+    }
 
     return ctl->info.value.enumerated.items;
 }
 
-int mixer_ctl_fill_enum_string(struct mixer_ctl *ctl)
+static int mixer_ctl_fill_enum_string(struct mixer_ctl *ctl)
 {
     struct mixer_ctl_group *grp = ctl->grp;
     struct snd_ctl_elem_info tmp;
@@ -1250,10 +1345,14 @@ fail:
 const char *mixer_ctl_get_enum_string(struct mixer_ctl *ctl,
                                       unsigned int enum_id)
 {
-    if (!ctl || (ctl->info.type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) ||
-        (enum_id >= ctl->info.value.enumerated.items) ||
-        mixer_ctl_fill_enum_string(ctl) != 0)
+    if (!ctl || ctl->info.type != SNDRV_CTL_ELEM_TYPE_ENUMERATED ||
+            enum_id >= ctl->info.value.enumerated.items) {
         return NULL;
+    }
+
+    if (mixer_ctl_fill_enum_string(ctl) < 0) {
+        return NULL;
+    }
 
     return (const char *)ctl->ename[enum_id];
 }
@@ -1272,9 +1371,13 @@ int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string)
     struct snd_ctl_elem_value ev;
     int ret;
 
-    if (!ctl || (ctl->info.type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) ||
-        mixer_ctl_fill_enum_string(ctl) != 0)
+    if (!ctl || !string || ctl->info.type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
         return -EINVAL;
+    }
+
+    if (mixer_ctl_fill_enum_string(ctl) < 0) {
+        return -EINVAL;
+    }
 
     grp = ctl->grp;
     num_enums = ctl->info.value.enumerated.items;
diff --git a/src/mixer_hw.c b/src/mixer_hw.c
index da5a390..50e9d07 100644
--- a/src/mixer_hw.c
+++ b/src/mixer_hw.c
@@ -42,6 +42,7 @@
 #include <sys/ioctl.h>
 
 #include <linux/ioctl.h>
+#include <time.h>
 #include <sound/asound.h>
 
 #include "mixer_io.h"
diff --git a/src/mixer_plugin.c b/src/mixer_plugin.c
index 34117a9..a07b8f6 100644
--- a/src/mixer_plugin.c
+++ b/src/mixer_plugin.c
@@ -82,7 +82,8 @@ static int mixer_plug_get_elem_id(struct mixer_plug_data *plug_data,
     id->iface = ctl->iface;
 
     strncpy((char *)id->name, (char *)ctl->name,
-            sizeof(id->name));
+            sizeof(id->name) - 1);
+    ((char *)id->name)[sizeof(id->name) - 1] = '\0';
 
     return 0;
 }
@@ -100,7 +101,8 @@ static int mixer_plug_info_enum(struct snd_control *ctl,
 
     strncpy(einfo->value.enumerated.name,
             val->texts[einfo->value.enumerated.item],
-            sizeof(einfo->value.enumerated.name));
+            sizeof(einfo->value.enumerated.name) - 1);
+    einfo->value.enumerated.name[sizeof(einfo->value.enumerated.name) - 1] = '\0';
 
     return 0;
 }
diff --git a/src/pcm.c b/src/pcm.c
index 10e477b..1b2103a 100644
--- a/src/pcm.c
+++ b/src/pcm.c
@@ -282,6 +282,11 @@ static unsigned int pcm_format_to_alsa(enum pcm_format format)
         return SNDRV_PCM_FORMAT_S32_LE;
     case PCM_FORMAT_S32_BE:
         return SNDRV_PCM_FORMAT_S32_BE;
+
+    case PCM_FORMAT_FLOAT_LE:
+        return SNDRV_PCM_FORMAT_FLOAT_LE;
+    case PCM_FORMAT_FLOAT_BE:
+        return SNDRV_PCM_FORMAT_FLOAT_BE;
     };
 }
 
@@ -300,7 +305,7 @@ struct pcm {
     /** Size of the buffer */
     unsigned int buffer_size;
     /** The boundary for ring buffer pointers */
-    unsigned int boundary;
+    unsigned long boundary;
     /** Description of the last error that occured */
     char error[PCM_ERROR_MAX];
     /** Configuration that was passed to @ref pcm_open */
@@ -522,10 +527,6 @@ int pcm_set_config(struct pcm *pcm, const struct pcm_config *config)
     sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
     sparams.silence_size = config->silence_size;
     sparams.silence_threshold = config->silence_threshold;
-    pcm->boundary = sparams.boundary = pcm->buffer_size;
-
-    while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
-        pcm->boundary *= 2;
 
     if (pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
         int errno_copy = errno;
@@ -533,6 +534,7 @@ int pcm_set_config(struct pcm *pcm, const struct pcm_config *config)
         return -errno_copy;
     }
 
+    pcm->boundary = sparams.boundary;
     return 0;
 }
 
@@ -556,6 +558,8 @@ unsigned int pcm_format_to_bits(enum pcm_format format)
     case PCM_FORMAT_S32_BE:
     case PCM_FORMAT_S24_LE:
     case PCM_FORMAT_S24_BE:
+    case PCM_FORMAT_FLOAT_LE:
+    case PCM_FORMAT_FLOAT_BE:
         return 32;
     case PCM_FORMAT_S24_3LE:
     case PCM_FORMAT_S24_3BE:
@@ -596,26 +600,33 @@ unsigned int pcm_frames_to_bytes(const struct pcm *pcm, unsigned int frames)
 static int pcm_sync_ptr(struct pcm *pcm, int flags)
 {
     if (pcm->sync_ptr == NULL) {
-        /* status and control are mmaped */
-
+        /* status and control are mmapped */
         if (flags & SNDRV_PCM_SYNC_PTR_HWSYNC) {
-            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HWSYNC) == -1) {
-                oops(pcm, errno, "failed to sync hardware pointer");
-                return -1;
+            if (pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_HWSYNC) == -1) {
+                return oops(pcm, errno, "failed to sync hardware pointer");
             }
         }
     } else {
         pcm->sync_ptr->flags = flags;
         if (pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_SYNC_PTR,
                             pcm->sync_ptr) < 0) {
-            oops(pcm, errno, "failed to sync mmap ptr");
-            return -1;
+            return oops(pcm, errno, "failed to sync mmap ptr");
         }
     }
 
     return 0;
 }
 
+int pcm_state(struct pcm *pcm)
+{
+    // Update the state only. Do not sync HW sync.
+    int err = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL | SNDRV_PCM_SYNC_PTR_AVAIL_MIN);
+    if (err < 0)
+        return err;
+
+    return pcm->mmap_status->state;
+}
+
 static int pcm_hw_mmap_status(struct pcm *pcm)
 {
     if (pcm->sync_ptr)
@@ -1081,8 +1092,10 @@ struct pcm *pcm_open(unsigned int card, unsigned int device,
     }
     pcm->subdevice = info.subdevice;
 
-    if (pcm_set_config(pcm, config) != 0)
+    if (pcm_set_config(pcm, config) != 0) {
+        memcpy(bad_pcm.error, pcm->error, sizeof(pcm->error));
         goto fail_close;
+    }
 
     rc = pcm_hw_mmap_status(pcm);
     if (rc < 0) {
@@ -1189,6 +1202,10 @@ int pcm_prepare(struct pcm *pcm)
  */
 int pcm_start(struct pcm *pcm)
 {
+    if (pcm_state(pcm) == PCM_STATE_SETUP && pcm_prepare(pcm) != 0) {
+        return -1;
+    }
+
     /* set appl_ptr and avail_min in kernel */
     if (pcm_sync_ptr(pcm, 0) < 0)
         return -1;
@@ -1201,6 +1218,22 @@ int pcm_start(struct pcm *pcm)
     return 0;
 }
 
+/** Drains a PCM.
+ * @param pcm A PCM handle.
+ * @return On success, zero; on failure, a negative number.
+ * @ingroup libtinyalsa-pcm
+ */
+int pcm_drain(struct pcm *pcm)
+{
+    if (!pcm_is_ready(pcm))
+        return -1;
+
+    if (pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_DRAIN) < 0)
+        return oops(pcm, errno, "cannot drain channel");
+
+    return 0;
+}
+
 /** Stops a PCM.
  * @param pcm A PCM handle.
  * @return On success, zero; on failure, a negative number.
@@ -1214,45 +1247,49 @@ int pcm_stop(struct pcm *pcm)
     return 0;
 }
 
-static inline int pcm_mmap_playback_avail(struct pcm *pcm)
+static inline long pcm_mmap_playback_avail(struct pcm *pcm)
 {
-    int avail;
+    long avail = pcm->mmap_status->hw_ptr + (unsigned long) pcm->buffer_size -
+            pcm->mmap_control->appl_ptr;
 
-    avail = pcm->mmap_status->hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
-
-    if (avail < 0)
+    if (avail < 0) {
         avail += pcm->boundary;
-    else if (avail >= (int)pcm->boundary)
+    } else if ((unsigned long) avail >= pcm->boundary) {
         avail -= pcm->boundary;
+    }
 
     return avail;
 }
 
-static inline int pcm_mmap_capture_avail(struct pcm *pcm)
+static inline long pcm_mmap_capture_avail(struct pcm *pcm)
 {
-    int avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
-    if (avail < 0)
+    long avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
+    if (avail < 0) {
         avail += pcm->boundary;
+    }
+
     return avail;
 }
 
 int pcm_mmap_avail(struct pcm *pcm)
 {
     pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
-    if (pcm->flags & PCM_IN)
-        return pcm_mmap_capture_avail(pcm);
-    else
-        return pcm_mmap_playback_avail(pcm);
+    if (pcm->flags & PCM_IN) {
+        return (int) pcm_mmap_capture_avail(pcm);
+    } else {
+        return (int) pcm_mmap_playback_avail(pcm);
+    }
 }
 
 static void pcm_mmap_appl_forward(struct pcm *pcm, int frames)
 {
-    unsigned int appl_ptr = pcm->mmap_control->appl_ptr;
+    unsigned long appl_ptr = pcm->mmap_control->appl_ptr;
     appl_ptr += frames;
 
     /* check for boundary wrap */
-    if (appl_ptr > pcm->boundary)
-         appl_ptr -= pcm->boundary;
+    if (appl_ptr >= pcm->boundary) {
+        appl_ptr -= pcm->boundary;
+    }
     pcm->mmap_control->appl_ptr = appl_ptr;
 }
 
@@ -1272,7 +1309,7 @@ int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
         avail = pcm->buffer_size;
     continuous = pcm->buffer_size - *offset;
 
-    /* we can only copy frames if the are availabale and continuos */
+    /* we can only copy frames if the are available and continuos */
     copy_frames = *frames;
     if (copy_frames > avail)
         copy_frames = avail;
@@ -1390,7 +1427,7 @@ again:
     *tstamp = pcm->mmap_status->tstamp;
 
     /*
-     * When status is mmaped, get avail again to ensure
+     * When status is mmapped, get avail again to ensure
      * valid timestamp.
      */
     if (!pcm->sync_ptr) {
@@ -1402,15 +1439,6 @@ again:
     return 0;
 }
 
-int pcm_state(struct pcm *pcm)
-{
-    int err = pcm_sync_ptr(pcm, 0);
-    if (err < 0)
-        return err;
-
-    return pcm->mmap_status->state;
-}
-
 /** Waits for frames to be available for read or write operations.
  * @param pcm A PCM handle.
  * @param timeout The maximum amount of time to wait for, in terms of milliseconds.
@@ -1461,22 +1489,22 @@ int pcm_wait(struct pcm *pcm, int timeout)
 }
 
 /*
- * Transfer data to/from mmaped buffer. This imitates the
+ * Transfer data to/from mmapped buffer. This imitates the
  * behavior of read/write system calls.
  *
  * However, this doesn't seems to offer any advantage over
  * the read/write syscalls. Should it be removed?
  */
-int pcm_mmap_transfer(struct pcm *pcm, void *buffer, unsigned int frames)
+static int pcm_mmap_transfer(struct pcm *pcm, void *buffer, unsigned int frames)
 {
     int is_playback;
 
     int state;
     unsigned int avail;
-    unsigned int user_offset;
+    unsigned int user_offset = 0;
 
     int err;
-    int tmp;
+    int transferred_frames;
 
     is_playback = !(pcm->flags & PCM_IN);
 
@@ -1496,17 +1524,15 @@ int pcm_mmap_transfer(struct pcm *pcm, void *buffer, unsigned int frames)
      * Another thread may start capture
      */
     if (!is_playback && state == PCM_STATE_PREPARED &&
-        frames >= pcm->config.start_threshold) {
-            err = pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_START);
-        if (err == -1)
+            frames >= pcm->config.start_threshold) {
+        if (pcm_start(pcm) < 0) {
             return -1;
-        /* state = PCM_STATE_RUNNING */
+        }
     }
 
-    avail = pcm_mmap_avail(pcm);
-    user_offset = 0;
-
     while (frames) {
+        avail = pcm_mmap_avail(pcm);
+
         if (!avail) {
             if (pcm->flags & PCM_NONBLOCK) {
                 errno = EAGAIN;
@@ -1519,25 +1545,22 @@ int pcm_mmap_transfer(struct pcm *pcm, void *buffer, unsigned int frames)
                 errno = -err;
                 break;
             }
-
-            /* get hardware pointer */
-            avail = pcm_avail_update(pcm);
         }
 
-        tmp = pcm_mmap_transfer_areas(pcm, buffer, user_offset, frames);
-        if (tmp < 0)
+        transferred_frames = pcm_mmap_transfer_areas(pcm, buffer, user_offset, frames);
+        if (transferred_frames < 0) {
             break;
+        }
 
-        user_offset += tmp;
-        frames -= tmp;
-        avail -= tmp;
+        user_offset += transferred_frames;
+        frames -= transferred_frames;
 
         /* start playback if written >= start_threshold */
         if (is_playback && state == PCM_STATE_PREPARED &&
-            pcm->buffer_size - avail >= pcm->config.start_threshold) {
-            err = pcm->ops->ioctl(pcm->data, SNDRV_PCM_IOCTL_START);
-            if (err == -1)
+                pcm->buffer_size - avail >= pcm->config.start_threshold) {
+            if (pcm_start(pcm) < 0) {
                 break;
+            }
         }
     }
 
diff --git a/src/pcm_hw.c b/src/pcm_hw.c
index 38b2e83..2383ae0 100644
--- a/src/pcm_hw.c
+++ b/src/pcm_hw.c
@@ -1,5 +1,7 @@
 /* pcm_hw.c
+**
 ** Copyright (c) 2019, The Linux Foundation.
+** Copyright 2021, The Android Open Source Project
 **
 ** Redistribution and use in source and binary forms, with or without
 ** modification, are permitted provided that the following conditions are
@@ -39,6 +41,7 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <linux/ioctl.h>
+#include <time.h>
 #include <sound/asound.h>
 #include <tinyalsa/asoundlib.h>
 
@@ -50,7 +53,7 @@ struct pcm_hw_data {
     /** Device number for the pcm device */
     unsigned int device;
     /** File descriptor to the pcm device file node */
-    unsigned int fd;
+    int fd;
     /** Pointer to the pcm node from snd card definiton */
     struct snd_node *node;
 };
@@ -59,7 +62,7 @@ static void pcm_hw_close(void *data)
 {
     struct pcm_hw_data *hw_data = data;
 
-    if (hw_data->fd > 0)
+    if (hw_data->fd >= 0)
         close(hw_data->fd);
 
     free(hw_data);
@@ -111,16 +114,25 @@ static int pcm_hw_open(unsigned int card, unsigned int device,
 
     snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
              flags & PCM_IN ? 'c' : 'p');
-    if (flags & PCM_NONBLOCK)
-        fd = open(fn, O_RDWR|O_NONBLOCK);
-    else
-        fd = open(fn, O_RDWR);
+    // Open the device with non-blocking flag to avoid to be blocked in kernel when all of the
+    //   substreams of this PCM device are opened by others.
+    fd = open(fn, O_RDWR | O_NONBLOCK);
 
     if (fd < 0) {
         free(hw_data);
         return fd;
     }
 
+    if ((flags & PCM_NONBLOCK) == 0) {
+        // Set the file descriptor to blocking mode.
+        if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) & ~O_NONBLOCK) < 0) {
+            fprintf(stderr, "failed to set to blocking mode on %s", fn);
+            close(fd);
+            free(hw_data);
+            return -ENODEV;
+        }
+    }
+
     hw_data->card = card;
     hw_data->device = device;
     hw_data->fd = fd;
diff --git a/src/pcm_plugin.c b/src/pcm_plugin.c
index 15bfc80..4d2651c 100644
--- a/src/pcm_plugin.c
+++ b/src/pcm_plugin.c
@@ -40,6 +40,7 @@
 
 #include <sys/ioctl.h>
 #include <linux/ioctl.h>
+#include <time.h>
 #include <sound/asound.h>
 #include <tinyalsa/asoundlib.h>
 #include <tinyalsa/plugin.h>
@@ -153,9 +154,12 @@ static int pcm_plug_info(struct pcm_plug_data *plug_data,
         return ret;
     }
 
-    strncpy((char *)info->id, name, sizeof(info->id));
-    strncpy((char *)info->name, name, sizeof(info->name));
-    strncpy((char *)info->subname, name, sizeof(info->subname));
+    strncpy((char *)info->id, name, sizeof(info->id) - 1);
+    ((char *)info->id)[sizeof(info->id) - 1] = '\0';
+    strncpy((char *)info->name, name, sizeof(info->name) - 1);
+    ((char *)info->name)[sizeof(info->name) - 1] = '\0';
+    strncpy((char *)info->subname, name, sizeof(info->subname) - 1);
+    ((char *)info->subname)[sizeof(info->subname) - 1] = '\0';
 
     info->subdevices_count = 1;
 
@@ -618,6 +622,16 @@ static int pcm_plug_drop(struct pcm_plug_data *plug_data)
     return rc;
 }
 
+static int pcm_plug_drain(struct pcm_plug_data *plug_data)
+{
+    struct pcm_plugin *plugin = plug_data->plugin;
+
+    if (plugin->state != PCM_PLUG_STATE_RUNNING)
+        return -EBADFD;
+
+    return plug_data->ops->drain(plugin);
+}
+
 static int pcm_plug_ioctl(void *data, unsigned int cmd, ...)
 {
     struct pcm_plug_data *plug_data = data;
@@ -655,6 +669,9 @@ static int pcm_plug_ioctl(void *data, unsigned int cmd, ...)
     case SNDRV_PCM_IOCTL_START:
         ret = pcm_plug_start(plug_data);
         break;
+    case SNDRV_PCM_IOCTL_DRAIN:
+        ret = pcm_plug_drain(plug_data);
+        break;
     case SNDRV_PCM_IOCTL_DROP:
         ret = pcm_plug_drop(plug_data);
         break;
diff --git a/tests/include/pcm_test_device.h b/tests/include/pcm_test_device.h
index 7ced192..a0ea811 100644
--- a/tests/include/pcm_test_device.h
+++ b/tests/include/pcm_test_device.h
@@ -29,6 +29,8 @@
 #ifndef TINYALSA_TESTS_PCM_TEST_H_
 #define TINYALSA_TESTS_PCM_TEST_H_
 
+#include "tinyalsa/pcm.h"
+
 namespace tinyalsa {
 namespace testing {
 
@@ -44,9 +46,25 @@ namespace testing {
 #define TEST_LOOPBACK_CAPTURE_DEVICE 1
 #endif
 
-constexpr unsigned int kLoopbackCard = TEST_LOOPBACK_CARD;
-constexpr unsigned int kLoopbackPlaybackDevice = TEST_LOOPBACK_PLAYBACK_DEVICE;
-constexpr unsigned int kLoopbackCaptureDevice = TEST_LOOPBACK_CAPTURE_DEVICE;
+static constexpr unsigned int kLoopbackCard = TEST_LOOPBACK_CARD;
+static constexpr unsigned int kLoopbackPlaybackDevice = TEST_LOOPBACK_PLAYBACK_DEVICE;
+static constexpr unsigned int kLoopbackCaptureDevice = TEST_LOOPBACK_CAPTURE_DEVICE;
+
+static constexpr unsigned int kDefaultChannels = 2;
+static constexpr unsigned int kDefaultSamplingRate = 48000;
+static constexpr unsigned int kDefaultPeriodSize = 1024;
+static constexpr unsigned int kDefaultPeriodCount = 3;
+static constexpr pcm_config kDefaultConfig = {
+    .channels = kDefaultChannels,
+    .rate = kDefaultSamplingRate,
+    .period_size = kDefaultPeriodSize,
+    .period_count = kDefaultPeriodCount,
+    .format = PCM_FORMAT_S16_LE,
+    .start_threshold = kDefaultPeriodSize,
+    .stop_threshold = kDefaultPeriodSize * kDefaultPeriodCount,
+    .silence_threshold = 0,
+    .silence_size = 0,
+};
 
 } // namespace testing
 } // namespace tinyalsa
diff --git a/tests/src/mixer_test.cc b/tests/src/mixer_test.cc
index 903fb8f..cbce3ec 100644
--- a/tests/src/mixer_test.cc
+++ b/tests/src/mixer_test.cc
@@ -27,6 +27,7 @@
 */
 #include "pcm_test_device.h"
 
+#include <limits>
 #include <string_view>
 #include <string>
 #include <thread>
@@ -51,8 +52,60 @@ static constexpr int k100Percent = 100;
 static constexpr int k0Percent = 0;
 
 TEST(MixerTest, OpenAndClose) {
-    ASSERT_EQ(mixer_open(1000), nullptr);
+    // assume card 0 is always probed.
+    mixer *mixer_object = mixer_open(0);
+    EXPECT_NE(mixer_object, nullptr);
+    mixer_close(mixer_object);
+}
+
+TEST(MixerTest, NullParametersCheck) {
+    EXPECT_EQ(mixer_open(1000), nullptr);
     mixer_close(nullptr);
+    EXPECT_EQ(mixer_add_new_ctls(nullptr), 0);
+    EXPECT_EQ(mixer_get_name(nullptr), nullptr);
+    EXPECT_EQ(mixer_get_num_ctls(nullptr), 0);
+    EXPECT_EQ(mixer_get_num_ctls_by_name(nullptr, ""), 0);
+    EXPECT_EQ(mixer_get_num_ctls_by_name(reinterpret_cast<const mixer *>(1), nullptr), 0);
+    EXPECT_EQ(mixer_get_ctl_const(nullptr, 0), nullptr);
+    EXPECT_EQ(mixer_get_ctl(nullptr, 0), nullptr);
+    EXPECT_EQ(mixer_get_ctl_by_name(nullptr, ""), nullptr);
+    EXPECT_EQ(mixer_get_ctl_by_name(reinterpret_cast<mixer *>(1), nullptr), nullptr);
+    EXPECT_EQ(mixer_get_ctl_by_name_and_index(nullptr, "", 0), nullptr);
+    EXPECT_EQ(
+            mixer_get_ctl_by_name_and_index(reinterpret_cast<mixer *>(1), nullptr, 0),
+            nullptr);
+    EXPECT_NE(mixer_subscribe_events(nullptr, 0), 0);
+    EXPECT_LT(mixer_wait_event(nullptr, 0), 0);
+    EXPECT_EQ(mixer_ctl_get_id(nullptr), std::numeric_limits<unsigned int>::max());
+    EXPECT_EQ(mixer_ctl_get_name(nullptr), nullptr);
+    EXPECT_EQ(mixer_ctl_get_type(nullptr), MIXER_CTL_TYPE_UNKNOWN);
+    EXPECT_STREQ(mixer_ctl_get_type_string(nullptr), "");
+    EXPECT_EQ(mixer_ctl_get_num_values(nullptr), 0);
+    EXPECT_EQ(mixer_ctl_get_num_enums(nullptr), 0);
+    EXPECT_EQ(mixer_ctl_get_enum_string(nullptr, 0), nullptr);
+    mixer_ctl_update(nullptr);
+    EXPECT_EQ(mixer_ctl_is_access_tlv_rw(nullptr), 0);
+    EXPECT_EQ(mixer_ctl_get_percent(nullptr, 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_percent(nullptr, 0, 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_get_value(nullptr, 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_get_array(nullptr, reinterpret_cast<void *>(1), 1), -EINVAL);
+    EXPECT_EQ(mixer_ctl_get_array(reinterpret_cast<mixer_ctl *>(1), nullptr, 1), -EINVAL);
+    EXPECT_EQ(
+            mixer_ctl_get_array(
+                reinterpret_cast<mixer_ctl *>(1), reinterpret_cast<void *>(1), 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_value(nullptr, 0, 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_array(nullptr, reinterpret_cast<const void *>(1), 1), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_array(reinterpret_cast<mixer_ctl *>(1), nullptr, 1), -EINVAL);
+    EXPECT_EQ(
+            mixer_ctl_set_array(
+                reinterpret_cast<mixer_ctl *>(1), reinterpret_cast<const void *>(1), 0), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_enum_by_string(nullptr, reinterpret_cast<const char *>(1)), -EINVAL);
+    EXPECT_EQ(mixer_ctl_set_enum_by_string(reinterpret_cast<mixer_ctl *>(1), nullptr), -EINVAL);
+    EXPECT_EQ(mixer_ctl_get_range_min(nullptr), -EINVAL);
+    EXPECT_EQ(mixer_ctl_get_range_max(nullptr), -EINVAL);
+    EXPECT_EQ(mixer_read_event(nullptr, reinterpret_cast<mixer_ctl_event *>(1)), -EINVAL);
+    EXPECT_EQ(mixer_read_event(reinterpret_cast<mixer *>(1), nullptr), -EINVAL);
+    EXPECT_EQ(mixer_consume_event(nullptr), -EINVAL);
 }
 
 class MixerTest : public ::testing::TestWithParam<unsigned int> {
@@ -105,9 +158,9 @@ class MixerControlsTest : public MixerTest {
 
         for (unsigned int i = 0; i < number_of_controls; i++) {
             controls[i] = mixer_get_ctl_const(mixer_object, i);
-            ASSERT_EQ(mixer_ctl_get_id(controls[i]), i);
-            ASSERT_STRNE(mixer_ctl_get_name(controls[i]), "");
-            ASSERT_NE(controls[i], nullptr);
+            EXPECT_EQ(mixer_ctl_get_id(controls[i]), i);
+            EXPECT_STRNE(mixer_ctl_get_name(controls[i]), "");
+            EXPECT_NE(controls[i], nullptr);
         }
     }
 
diff --git a/tests/src/pcm_loopback_test.cc b/tests/src/pcm_loopback_test.cc
index 6a3ffb8..3da3231 100644
--- a/tests/src/pcm_loopback_test.cc
+++ b/tests/src/pcm_loopback_test.cc
@@ -64,6 +64,7 @@ public:
 template<pcm_format F>
 struct PcmFormat {
     using Type = void;
+    static constexpr pcm_format kFormat = F;
     static constexpr int32_t kMax = 0;
     static constexpr int32_t kMin = 0;
 };
@@ -71,10 +72,19 @@ struct PcmFormat {
 template<>
 struct PcmFormat<PCM_FORMAT_S16_LE> {
     using Type = int16_t;
+    static constexpr pcm_format kFormat = PCM_FORMAT_S16_LE;
     static constexpr Type kMax = std::numeric_limits<Type>::max();
     static constexpr Type kMin = std::numeric_limits<Type>::min();
 };
 
+template<>
+struct PcmFormat<PCM_FORMAT_FLOAT_LE> {
+    using Type = float;
+    static constexpr pcm_format kFormat = PCM_FORMAT_FLOAT_LE;
+    static constexpr Type kMax = 1.0;
+    static constexpr Type kMin = -1.0;
+};
+
 // CH: channels
 // SR: sampling rate
 // FQ: sine wave frequency
@@ -139,43 +149,69 @@ static double Energy(T *buffer, size_t samples) {
     return sum;
 }
 
-TEST(PcmLoopbackTest, LoopbackS16le) {
-    static constexpr unsigned int kDefaultChannels = 2;
-    static constexpr unsigned int kDefaultSamplingRate = 48000;
-    static constexpr unsigned int kDefaultPeriodSize = 1024;
-    static constexpr unsigned int kDefaultPeriodCount = 3;
+template<typename F>
+class PcmLoopbackTest : public ::testing::Test {
+  protected:
+    PcmLoopbackTest() = default;
+    virtual ~PcmLoopbackTest() = default;
+
+    void SetUp() override {
+        static constexpr pcm_config kInConfig = {
+            .channels = kDefaultChannels,
+            .rate = kDefaultSamplingRate,
+            .period_size = kDefaultPeriodSize,
+            .period_count = kDefaultPeriodCount,
+            .format = kPcmForamt,
+            .start_threshold = 0,
+            .stop_threshold = 0,
+            .silence_threshold = 0,
+            .silence_size = 0,
+        };
+        pcm_in = pcm_open(kLoopbackCard, kLoopbackCaptureDevice, PCM_IN, &kInConfig);
+        ASSERT_TRUE(pcm_is_ready(pcm_in));
+
+        static constexpr pcm_config kOutConfig = {
+            .channels = kDefaultChannels,
+            .rate = kDefaultSamplingRate,
+            .period_size = kDefaultPeriodSize,
+            .period_count = kDefaultPeriodCount,
+            .format = kPcmForamt,
+            .start_threshold = kDefaultPeriodSize,
+            .stop_threshold = kDefaultPeriodSize * kDefaultPeriodCount,
+            .silence_threshold = 0,
+            .silence_size = 0,
+        };
+        pcm_out = pcm_open(kLoopbackCard, kLoopbackPlaybackDevice, PCM_OUT, &kOutConfig);
+        ASSERT_TRUE(pcm_is_ready(pcm_out));
+        ASSERT_EQ(pcm_link(pcm_in, pcm_out), 0);
+    }
+
+    void TearDown() override {
+        ASSERT_EQ(pcm_unlink(pcm_in), 0);
+        pcm_close(pcm_in);
+        pcm_close(pcm_out);
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    }
+
     static constexpr unsigned int kDefaultPeriodTimeInMs =
             kDefaultPeriodSize * 1000 / kDefaultSamplingRate;
+    static constexpr pcm_format kPcmForamt = F::kFormat;
+    pcm *pcm_in;
+    pcm *pcm_out;
+};
 
-    static constexpr pcm_config kInConfig = {
-        .channels = kDefaultChannels,
-        .rate = kDefaultSamplingRate,
-        .period_size = kDefaultPeriodSize,
-        .period_count = kDefaultPeriodCount,
-        .format = PCM_FORMAT_S16_LE,
-        .start_threshold = 0,
-        .stop_threshold = 0,
-        .silence_threshold = 0,
-        .silence_size = 0,
-    };
-    pcm *pcm_in = pcm_open(kLoopbackCard, kLoopbackCaptureDevice, PCM_IN, &kInConfig);
-    ASSERT_TRUE(pcm_is_ready(pcm_in));
-
-    static constexpr pcm_config kOutConfig = {
-        .channels = kDefaultChannels,
-        .rate = kDefaultSamplingRate,
-        .period_size = kDefaultPeriodSize,
-        .period_count = kDefaultPeriodCount,
-        .format = PCM_FORMAT_S16_LE,
-        .start_threshold = kDefaultPeriodSize,
-        .stop_threshold = kDefaultPeriodSize * kDefaultPeriodCount,
-        .silence_threshold = 0,
-        .silence_size = 0,
-    };
-    pcm *pcm_out = pcm_open(kLoopbackCard, kLoopbackPlaybackDevice, PCM_OUT, &kOutConfig);
-    ASSERT_TRUE(pcm_is_ready(pcm_out));
+using S16bitlePcmFormat = PcmFormat<PCM_FORMAT_S16_LE>;
+using FloatPcmFormat = PcmFormat<PCM_FORMAT_FLOAT_LE>;
 
-    ASSERT_EQ(pcm_link(pcm_in, pcm_out), 0);
+using Formats = ::testing::Types<S16bitlePcmFormat, FloatPcmFormat>;
+
+TYPED_TEST_SUITE(PcmLoopbackTest, Formats);
+
+TYPED_TEST(PcmLoopbackTest, Loopback) {
+    static constexpr unsigned int kDefaultPeriodTimeInMs = this->kDefaultPeriodTimeInMs;
+    static constexpr pcm_format kPcmForamt = this->kPcmForamt;
+    pcm *pcm_in = this->pcm_in;
+    pcm *pcm_out = this->pcm_out;
 
     bool stopping = false;
     ASSERT_EQ(pcm_get_subdevice(pcm_in), pcm_get_subdevice(pcm_out));
@@ -190,23 +226,26 @@ TEST(PcmLoopbackTest, LoopbackS16le) {
             if (res == -1) {
                 std::cout << pcm_get_error(pcm_in) << std::endl;
                 std::this_thread::sleep_for(std::chrono::milliseconds(kDefaultPeriodTimeInMs));
+                counter++;
                 continue;
             }
-            EXPECT_EQ(pcm_readi(pcm_in, buffer.get(), frames), frames) << counter;
+
             // Test the energy of the buffer after the sine tone samples fill in the buffer.
             // Therefore, check the buffer 5 times later.
             if (counter >= 5) {
-                double e = Energy(buffer.get(), frames * kInConfig.channels);
+                double e = Energy(buffer.get(), frames * kDefaultChannels);
                 EXPECT_GT(e, 0.0) << counter;
             }
             counter++;
         }
+        std::cout << "read count = " << counter << std::endl;
     });
 
     std::thread playback([pcm_out, &stopping] {
-        SineToneGenerator<2, 48000, 1000, 0, PCM_FORMAT_S16_LE> generator;
+        SineToneGenerator<kDefaultChannels, kDefaultSamplingRate, 1000, 0, kPcmForamt> generator;
         size_t buffer_size = pcm_frames_to_bytes(pcm_out, kDefaultPeriodSize);
         unsigned int frames = pcm_bytes_to_frames(pcm_out, buffer_size);
+        std::cout << buffer_size << std::endl;
         auto buffer = std::make_unique<unsigned char[]>(buffer_size);
         int32_t counter = 0;
         while (!stopping) {
@@ -214,16 +253,13 @@ TEST(PcmLoopbackTest, LoopbackS16le) {
             EXPECT_EQ(pcm_writei(pcm_out, buffer.get(), frames), frames) << counter;
             counter++;
         }
+        std::cout << "write count = " << counter << std::endl;
     });
 
-    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::this_thread::sleep_for(std::chrono::milliseconds(500));
     stopping = true;
     capture.join();
     playback.join();
-
-    ASSERT_EQ(pcm_unlink(pcm_in), 0);
-    pcm_close(pcm_in);
-    pcm_close(pcm_out);
 }
 
 } // namespace testing
diff --git a/tests/src/pcm_test.cc b/tests/src/pcm_test.cc
index 2668350..9a14aa2 100644
--- a/tests/src/pcm_test.cc
+++ b/tests/src/pcm_test.cc
@@ -26,13 +26,20 @@
 ** DAMAGE.
 */
 
-#include <string>
+#include <cstdio>
+#include <fstream>
 #include <iostream>
+#include <memory>
+#include <string_view>
+#include <string>
+#include <thread>
 
 #include <gtest/gtest.h>
 
 #include "tinyalsa/pcm.h"
 
+#include "pcm_test_device.h"
+
 namespace tinyalsa {
 namespace testing {
 
@@ -49,25 +56,11 @@ TEST(PcmTest, FormatToBits) {
     ASSERT_EQ(pcm_format_to_bits(PCM_FORMAT_S24_BE), 32);
     ASSERT_EQ(pcm_format_to_bits(PCM_FORMAT_S24_3BE), 24);
     ASSERT_EQ(pcm_format_to_bits(PCM_FORMAT_S32_BE), 32);
+    ASSERT_EQ(pcm_format_to_bits(PCM_FORMAT_FLOAT_LE), 32);
+    ASSERT_EQ(pcm_format_to_bits(PCM_FORMAT_FLOAT_BE), 32);
 }
 
 TEST(PcmTest, OpenAndCloseOutPcm) {
-    static constexpr unsigned int kDefaultChannels = 2;
-    static constexpr unsigned int kDefaultSamplingRate = 48000;
-    static constexpr unsigned int kDefaultPeriodSize = 1024;
-    static constexpr unsigned int kDefaultPeriodCount = 3;
-    static constexpr pcm_config kDefaultConfig = {
-        .channels = kDefaultChannels,
-        .rate = kDefaultSamplingRate,
-        .period_size = kDefaultPeriodSize,
-        .period_count = kDefaultPeriodCount,
-        .format = PCM_FORMAT_S16_LE,
-        .start_threshold = kDefaultPeriodSize,
-        .stop_threshold = kDefaultPeriodSize * kDefaultPeriodCount,
-        .silence_threshold = 0,
-        .silence_size = 0,
-    };
-
     pcm *pcm_object = pcm_open(1000, 1000, PCM_OUT, &kDefaultConfig);
     ASSERT_FALSE(pcm_is_ready(pcm_object));
     ASSERT_EQ(pcm_close(pcm_object), 0);
@@ -99,5 +92,72 @@ TEST(PcmTest, OpenAndCloseOutPcm) {
     ASSERT_EQ(pcm_close(pcm_object), 0);
 }
 
+TEST(PcmTest, OpenWithoutBlocking) {
+    char loopback_device_info_path[120] = {};
+    snprintf(loopback_device_info_path, sizeof(loopback_device_info_path),
+            "/proc/asound/card%d/pcm%dp/info", kLoopbackCard, kLoopbackPlaybackDevice);
+
+    std::ifstream info_file_stream{loopback_device_info_path};
+    if (!info_file_stream.is_open()) {
+        GTEST_SKIP();
+    }
+
+    char buffer[256] = {};
+    int32_t subdevice_count = 0;
+    while (info_file_stream.good()) {
+        info_file_stream.getline(buffer, sizeof(buffer));
+        std::cout << buffer << std::endl;
+        std::string_view line{buffer};
+        if (line.find("subdevices_count") != std::string_view::npos) {
+            auto subdevice_count_string = line.substr(line.find(":") + 1);
+            std::cout << subdevice_count_string << std::endl;
+            subdevice_count = std::stoi(std::string{subdevice_count_string});
+        }
+    }
+
+    ASSERT_GT(subdevice_count, 0);
+
+    auto pcm_array = std::make_unique<pcm *[]>(subdevice_count);
+    std::thread *open_thread = new std::thread{[&pcm_array, subdevice_count] {
+        // Occupy all substreams
+        for (int32_t i = 0; i < subdevice_count; i++) {
+            pcm_array[i] = pcm_open(kLoopbackCard, kLoopbackPlaybackDevice, PCM_OUT,
+                    &kDefaultConfig);
+            EXPECT_TRUE(pcm_is_ready(pcm_array[i]));
+        }
+
+        // Expect that pcm_open is not blocked in the kernel and return a bad_object pointer.
+        pcm *pcm_object = pcm_open(kLoopbackCard, kLoopbackPlaybackDevice, PCM_OUT,
+                    &kDefaultConfig);
+        if (pcm_is_ready(pcm_object)) {
+            // open_thread is blocked in kernel because of the substream is all occupied. pcm_open
+            // returns because the main thread has released all pcm structures in pcm_array. We just
+            // need to close the pcm_object here.
+            pcm_close(pcm_object);
+            return;
+        }
+
+        // Release all substreams
+        for (int32_t i = 0; i < subdevice_count; i++) {
+            pcm_close(pcm_array[i]);
+            pcm_array[i] = nullptr;
+        }
+    }};
+
+    static constexpr int64_t kTimeoutMs = 500;
+    std::this_thread::sleep_for(std::chrono::milliseconds(kTimeoutMs));
+    if (pcm_array[0] == nullptr) {
+        open_thread->join();
+    } else {
+        for (int32_t i = 0; i < subdevice_count; i++) {
+            pcm_close(pcm_array[i]);
+            pcm_array[i] = nullptr;
+        }
+        open_thread->join();
+        FAIL() << "The open_thread is blocked in kernel or the kTimeoutMs(" << kTimeoutMs <<
+                ") is too short to complete";
+    }
+}
+
 } // namespace testing
 } // namespace tinyalsa
diff --git a/utils/tinycap.1 b/utils/tinycap.1
index ad60a2e..d18dd12 100644
--- a/utils/tinycap.1
+++ b/utils/tinycap.1
@@ -23,6 +23,11 @@ The default is 0.
 Device number of the PCM.
 The default is 0.
 
+.TP
+\fB\-M\fR
+Use memory-mapped I/O method.
+If this option is not specified, then read and write I/O method will be used.
+
 .TP
 \fB\-c\fR \fIchannels\fR
 Number of channels the PCM will have.
diff --git a/utils/tinycap.c b/utils/tinycap.c
index 7d4b8a4..617d16a 100644
--- a/utils/tinycap.c
+++ b/utils/tinycap.c
@@ -30,6 +30,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
+#include <stdbool.h>
 #include <signal.h>
 #include <string.h>
 #include <limits.h>
@@ -64,7 +65,7 @@ int capturing = 1;
 int prinfo = 1;
 
 unsigned int capture_sample(FILE *file, unsigned int card, unsigned int device,
-                            unsigned int channels, unsigned int rate,
+                            bool use_mmap, unsigned int channels, unsigned int rate,
                             enum pcm_format format, unsigned int period_size,
                             unsigned int period_count, unsigned int capture_time);
 
@@ -88,12 +89,13 @@ int main(int argc, char **argv)
     unsigned int period_size = 1024;
     unsigned int period_count = 4;
     unsigned int capture_time = UINT_MAX;
+    bool use_mmap = false;
     enum pcm_format format;
     int no_header = 0, c;
     struct optparse opts;
 
     if (argc < 2) {
-        fprintf(stderr, "Usage: %s {file.wav | --} [-D card] [-d device] [-c channels] "
+        fprintf(stderr, "Usage: %s {file.wav | --} [-D card] [-d device] [-M] [-c channels] "
                 "[-r rate] [-b bits] [-p period_size] [-n n_periods] [-t time_in_seconds]\n\n"
                 "Use -- for filename to send raw PCM to stdout\n", argv[0]);
         return 1;
@@ -113,7 +115,7 @@ int main(int argc, char **argv)
 
     /* parse command line arguments */
     optparse_init(&opts, argv + 1);
-    while ((c = optparse(&opts, "D:d:c:r:b:p:n:t:")) != -1) {
+    while ((c = optparse(&opts, "D:d:c:r:b:p:n:t:M")) != -1) {
         switch (c) {
         case 'd':
             device = atoi(opts.optarg);
@@ -139,6 +141,9 @@ int main(int argc, char **argv)
         case 't':
             capture_time = atoi(opts.optarg);
             break;
+        case 'M':
+            use_mmap = true;
+            break;
         case '?':
             fprintf(stderr, "%s\n", opts.errmsg);
             return EXIT_FAILURE;
@@ -182,9 +187,9 @@ int main(int argc, char **argv)
 
     /* install signal handler and begin capturing */
     signal(SIGINT, sigint_handler);
-    frames = capture_sample(file, card, device, header.num_channels,
-                            header.sample_rate, format,
-                            period_size, period_count, capture_time);
+    frames = capture_sample(file, card, device, use_mmap,
+                            header.num_channels, header.sample_rate,
+                            format, period_size, period_count, capture_time);
     if (prinfo) {
         printf("Captured %u frames\n", frames);
     }
@@ -203,11 +208,12 @@ int main(int argc, char **argv)
 }
 
 unsigned int capture_sample(FILE *file, unsigned int card, unsigned int device,
-                            unsigned int channels, unsigned int rate,
+                            bool use_mmap, unsigned int channels, unsigned int rate,
                             enum pcm_format format, unsigned int period_size,
                             unsigned int period_count, unsigned int capture_time)
 {
     struct pcm_config config;
+    unsigned int pcm_open_flags;
     struct pcm *pcm;
     char *buffer;
     unsigned int size;
@@ -225,7 +231,11 @@ unsigned int capture_sample(FILE *file, unsigned int card, unsigned int device,
     config.stop_threshold = 0;
     config.silence_threshold = 0;
 
-    pcm = pcm_open(card, device, PCM_IN, &config);
+    pcm_open_flags = PCM_IN;
+    if (use_mmap)
+        pcm_open_flags |= PCM_MMAP;
+
+    pcm = pcm_open(card, device, pcm_open_flags, &config);
     if (!pcm || !pcm_is_ready(pcm)) {
         fprintf(stderr, "Unable to open PCM device (%s)\n",
                 pcm_get_error(pcm));
diff --git a/utils/tinymix.c b/utils/tinymix.c
index e272ade..edeb6ad 100644
--- a/utils/tinymix.c
+++ b/utils/tinymix.c
@@ -201,7 +201,7 @@ static void list_controls(struct mixer *mixer, int print_all)
 {
     struct mixer_ctl *ctl;
     const char *name, *type;
-    unsigned int num_ctls, num_values;
+    unsigned int num_ctls, num_values, device;
     unsigned int i;
 
     num_ctls = mixer_get_num_ctls(mixer);
@@ -209,9 +209,9 @@ static void list_controls(struct mixer *mixer, int print_all)
     printf("Number of controls: %u\n", num_ctls);
 
     if (print_all)
-        printf("ctl\ttype\tnum\t%-40svalue\n", "name");
+        printf("ctl\ttype\tnum\t%-40s\tdevice\tvalue\n", "name");
     else
-        printf("ctl\ttype\tnum\t%-40s\n", "name");
+        printf("ctl\ttype\tnum\t%-40s\tdevice\n", "name");
 
     for (i = 0; i < num_ctls; i++) {
         ctl = mixer_get_ctl(mixer, i);
@@ -219,7 +219,8 @@ static void list_controls(struct mixer *mixer, int print_all)
         name = mixer_ctl_get_name(ctl);
         type = mixer_ctl_get_type_string(ctl);
         num_values = mixer_ctl_get_num_values(ctl);
-        printf("%u\t%s\t%u\t%-40s", i, type, num_values, name);
+        device = mixer_ctl_get_device(ctl);
+        printf("%u\t%s\t%u\t%-40s\t%u", i, type, num_values, name, device);
         if (print_all)
             print_control_values(ctl);
         printf("\n");
diff --git a/utils/tinyplay.c b/utils/tinyplay.c
index 4c7ccf6..d617074 100644
--- a/utils/tinyplay.c
+++ b/utils/tinyplay.c
@@ -27,11 +27,12 @@
 */
 
 #include <tinyalsa/asoundlib.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <stdint.h>
 #include <string.h>
-#include <signal.h>
 
 #define OPTPARSE_IMPLEMENTATION
 #include "optparse.h"
@@ -44,6 +45,7 @@ struct cmd {
     int flags;
     struct pcm_config config;
     unsigned int bits;
+    bool is_float;
 };
 
 void cmd_init(struct cmd *cmd)
@@ -63,6 +65,7 @@ void cmd_init(struct cmd *cmd)
     cmd->config.stop_threshold = cmd->config.period_size * cmd->config.period_count;
     cmd->config.start_threshold = cmd->config.period_size;
     cmd->bits = 16;
+    cmd->is_float = false;
 }
 
 #define ID_RIFF 0x46464952
@@ -70,6 +73,9 @@ void cmd_init(struct cmd *cmd)
 #define ID_FMT  0x20746d66
 #define ID_DATA 0x61746164
 
+#define WAVE_FORMAT_PCM 0x0001
+#define WAVE_FORMAT_IEEE_FLOAT 0x0003
+
 struct riff_wave_header {
     uint32_t riff_id;
     uint32_t riff_sz;
@@ -98,12 +104,77 @@ struct ctx {
     struct chunk_fmt chunk_fmt;
 
     FILE *file;
+    size_t file_size;
 };
 
-int ctx_init(struct ctx* ctx, const struct cmd *cmd)
+static bool is_wave_file(const char *filetype)
+{
+    return filetype != NULL && strcmp(filetype, "wav") == 0;
+}
+
+static enum pcm_format signed_pcm_bits_to_format(int bits)
+{
+    switch (bits) {
+    case 8:
+        return PCM_FORMAT_S8;
+    case 16:
+        return PCM_FORMAT_S16_LE;
+    case 24:
+        return PCM_FORMAT_S24_3LE;
+    case 32:
+        return PCM_FORMAT_S32_LE;
+    default:
+        return -1;
+    }
+}
+
+static int parse_wave_file(struct ctx *ctx, const char *filename)
+{
+    if (fread(&ctx->wave_header, sizeof(ctx->wave_header), 1, ctx->file) != 1){
+        fprintf(stderr, "error: '%s' does not contain a riff/wave header\n", filename);
+        return -1;
+    }
+
+    if (ctx->wave_header.riff_id != ID_RIFF || ctx->wave_header.wave_id != ID_WAVE) {
+        fprintf(stderr, "error: '%s' is not a riff/wave file\n", filename);
+        return -1;
+    }
+
+    bool more_chunks = true;
+    do {
+        if (fread(&ctx->chunk_header, sizeof(ctx->chunk_header), 1, ctx->file) != 1) {
+            fprintf(stderr, "error: '%s' does not contain a data chunk\n", filename);
+            return -1;
+        }
+        switch (ctx->chunk_header.id) {
+        case ID_FMT:
+            if (fread(&ctx->chunk_fmt, sizeof(ctx->chunk_fmt), 1, ctx->file) != 1) {
+                fprintf(stderr, "error: '%s' has incomplete format chunk\n", filename);
+                return -1;
+            }
+            /* If the format header is larger, skip the rest */
+            if (ctx->chunk_header.sz > sizeof(ctx->chunk_fmt)) {
+                fseek(ctx->file, ctx->chunk_header.sz - sizeof(ctx->chunk_fmt), SEEK_CUR);
+            }
+            break;
+        case ID_DATA:
+            /* Stop looking for chunks */
+            more_chunks = false;
+            break;
+        default:
+            /* Unknown chunk, skip bytes */
+            fseek(ctx->file, ctx->chunk_header.sz, SEEK_CUR);
+        }
+    } while (more_chunks);
+
+    return 0;
+}
+
+static int ctx_init(struct ctx* ctx, struct cmd *cmd)
 {
     unsigned int bits = cmd->bits;
-    struct pcm_config config = cmd->config;
+    struct pcm_config *config = &cmd->config;
+    bool is_float = cmd->is_float;
 
     if (cmd->filename == NULL) {
         fprintf(stderr, "filename not specified\n");
@@ -113,6 +184,9 @@ int ctx_init(struct ctx* ctx, const struct cmd *cmd)
         ctx->file = stdin;
     } else {
         ctx->file = fopen(cmd->filename, "rb");
+        fseek(ctx->file, 0L, SEEK_END);
+        ctx->file_size = ftell(ctx->file);
+        fseek(ctx->file, 0L, SEEK_SET);
     }
 
     if (ctx->file == NULL) {
@@ -120,74 +194,37 @@ int ctx_init(struct ctx* ctx, const struct cmd *cmd)
         return -1;
     }
 
-    if ((cmd->filetype != NULL) && (strcmp(cmd->filetype, "wav") == 0)) {
-        if (fread(&ctx->wave_header, sizeof(ctx->wave_header), 1, ctx->file) != 1){
-            fprintf(stderr, "error: '%s' does not contain a riff/wave header\n", cmd->filename);
-            fclose(ctx->file);
-            return -1;
-        }
-        if ((ctx->wave_header.riff_id != ID_RIFF) ||
-            (ctx->wave_header.wave_id != ID_WAVE)) {
-            fprintf(stderr, "error: '%s' is not a riff/wave file\n", cmd->filename);
+    if (is_wave_file(cmd->filetype)) {
+        if (parse_wave_file(ctx, cmd->filename) != 0) {
             fclose(ctx->file);
             return -1;
         }
-        unsigned int more_chunks = 1;
-        do {
-            if (fread(&ctx->chunk_header, sizeof(ctx->chunk_header), 1, ctx->file) != 1){
-                fprintf(stderr, "error: '%s' does not contain a data chunk\n", cmd->filename);
-                fclose(ctx->file);
-                return -1;
-            }
-            switch (ctx->chunk_header.id) {
-            case ID_FMT:
-                if (fread(&ctx->chunk_fmt, sizeof(ctx->chunk_fmt), 1, ctx->file) != 1){
-                    fprintf(stderr, "error: '%s' has incomplete format chunk\n", cmd->filename);
-                    fclose(ctx->file);
-                    return -1;
-                }
-                /* If the format header is larger, skip the rest */
-                if (ctx->chunk_header.sz > sizeof(ctx->chunk_fmt))
-                    fseek(ctx->file, ctx->chunk_header.sz - sizeof(ctx->chunk_fmt), SEEK_CUR);
-                break;
-            case ID_DATA:
-                /* Stop looking for chunks */
-                more_chunks = 0;
-                break;
-            default:
-                /* Unknown chunk, skip bytes */
-                fseek(ctx->file, ctx->chunk_header.sz, SEEK_CUR);
-            }
-        } while (more_chunks);
-        config.channels = ctx->chunk_fmt.num_channels;
-        config.rate = ctx->chunk_fmt.sample_rate;
+        config->channels = ctx->chunk_fmt.num_channels;
+        config->rate = ctx->chunk_fmt.sample_rate;
         bits = ctx->chunk_fmt.bits_per_sample;
+        is_float = ctx->chunk_fmt.audio_format == WAVE_FORMAT_IEEE_FLOAT;
+        ctx->file_size = (size_t) ctx->chunk_header.sz;
     }
 
-    if (bits == 8) {
-        config.format = PCM_FORMAT_S8;
-    } else if (bits == 16) {
-        config.format = PCM_FORMAT_S16_LE;
-    } else if (bits == 24) {
-        config.format = PCM_FORMAT_S24_3LE;
-    } else if (bits == 32) {
-        config.format = PCM_FORMAT_S32_LE;
+    if (is_float) {
+        config->format = PCM_FORMAT_FLOAT_LE;
     } else {
-        fprintf(stderr, "bit count '%u' not supported\n", bits);
-        fclose(ctx->file);
-        return -1;
+        config->format = signed_pcm_bits_to_format(bits);
+        if (config->format == -1) {
+            fprintf(stderr, "bit count '%u' not supported\n", bits);
+            fclose(ctx->file);
+            return -1;
+        }
     }
 
     ctx->pcm = pcm_open(cmd->card,
                         cmd->device,
                         cmd->flags,
-                        &config);
-    if (ctx->pcm == NULL) {
-        fprintf(stderr, "failed to allocate memory for pcm\n");
-        fclose(ctx->file);
-        return -1;
-    } else if (!pcm_is_ready(ctx->pcm)) {
-        fprintf(stderr, "failed to open for pcm %u,%u\n", cmd->card, cmd->device);
+                        config);
+    if (!pcm_is_ready(ctx->pcm)) {
+        fprintf(stderr, "failed to open for pcm %u,%u. %s\n",
+                cmd->card, cmd->device,
+                pcm_get_error(ctx->pcm));
         fclose(ctx->file);
         pcm_close(ctx->pcm);
         return -1;
@@ -228,10 +265,11 @@ void print_usage(const char *argv0)
     fprintf(stderr, "-d | --device <device number>  The device to receive the audio\n");
     fprintf(stderr, "-p | --period-size <size>      The size of the PCM's period\n");
     fprintf(stderr, "-n | --period-count <count>    The number of PCM periods\n");
-    fprintf(stderr, "-i | --file-type <file-type >  The type of file to read (raw or wav)\n");
+    fprintf(stderr, "-i | --file-type <file-type>   The type of file to read (raw or wav)\n");
     fprintf(stderr, "-c | --channels <count>        The amount of channels per frame\n");
     fprintf(stderr, "-r | --rate <rate>             The amount of frames per second\n");
     fprintf(stderr, "-b | --bits <bit-count>        The number of bits in one sample\n");
+    fprintf(stderr, "-f | --float                   The frames are in floating-point PCM\n");
     fprintf(stderr, "-M | --mmap                    Use memory mapped IO to play audio\n");
 }
 
@@ -250,6 +288,7 @@ int main(int argc, char **argv)
         { "channels",     'c', OPTPARSE_REQUIRED },
         { "rate",         'r', OPTPARSE_REQUIRED },
         { "bits",         'b', OPTPARSE_REQUIRED },
+        { "float",        'f', OPTPARSE_NONE     },
         { "mmap",         'M', OPTPARSE_NONE     },
         { "help",         'h', OPTPARSE_NONE     },
         { 0, 0, 0 }
@@ -303,6 +342,15 @@ int main(int argc, char **argv)
         case 'i':
             cmd.filetype = opts.optarg;
             break;
+        case 'b':
+            if (sscanf(opts.optarg, "%u", &cmd.bits) != 1) {
+                fprintf(stderr, "failed parsing bits per one sample '%s'\n", argv[1]);
+                return EXIT_FAILURE;
+            }
+            break;
+        case 'f':
+            cmd.is_float = true;
+            break;
         case 'M':
             cmd.flags |= PCM_MMAP;
             break;
@@ -329,12 +377,13 @@ int main(int argc, char **argv)
         return EXIT_FAILURE;
     }
 
-    /* TODO get parameters from context */
-    printf("playing '%s': %u ch, %u hz, %u bit\n",
-           cmd.filename,
-           cmd.config.channels,
-           cmd.config.rate,
-           cmd.bits);
+    printf("playing '%s': %u ch, %u hz, %u-bit ", cmd.filename, cmd.config.channels,
+            cmd.config.rate, pcm_format_to_bits(cmd.config.format));
+    if (cmd.config.format == PCM_FORMAT_FLOAT_LE) {
+        printf("floating-point PCM\n");
+    } else {
+        printf("signed PCM\n");
+    }
 
     if (play_sample(&ctx) < 0) {
         ctx_free(&ctx);
@@ -350,20 +399,20 @@ int check_param(struct pcm_params *params, unsigned int param, unsigned int valu
 {
     unsigned int min;
     unsigned int max;
-    int is_within_bounds = 1;
+    bool is_within_bounds = true;
 
     min = pcm_params_get_min(params, param);
     if (value < min) {
         fprintf(stderr, "%s is %u%s, device only supports >= %u%s\n", param_name, value,
                 param_unit, min, param_unit);
-        is_within_bounds = 0;
+        is_within_bounds = false;
     }
 
     max = pcm_params_get_max(params, param);
     if (value > max) {
         fprintf(stderr, "%s is %u%s, device only supports <= %u%s\n", param_name, value,
                 param_unit, max, param_unit);
-        is_within_bounds = 0;
+        is_within_bounds = false;
     }
 
     return is_within_bounds;
@@ -381,12 +430,13 @@ int sample_is_playable(const struct cmd *cmd)
     }
 
     can_play = check_param(params, PCM_PARAM_RATE, cmd->config.rate, "sample rate", "hz");
-    can_play &= check_param(params, PCM_PARAM_CHANNELS, cmd->config.channels, "sample", " channels");
+    can_play &= check_param(params, PCM_PARAM_CHANNELS, cmd->config.channels, "sample",
+            " channels");
     can_play &= check_param(params, PCM_PARAM_SAMPLE_BITS, cmd->bits, "bits", " bits");
     can_play &= check_param(params, PCM_PARAM_PERIOD_SIZE, cmd->config.period_size, "period size",
-                            " frames");
+            " frames");
     can_play &= check_param(params, PCM_PARAM_PERIODS, cmd->config.period_count, "period count",
-                            " frames");
+            "");
 
     pcm_params_free(params);
 
@@ -396,9 +446,11 @@ int sample_is_playable(const struct cmd *cmd)
 int play_sample(struct ctx *ctx)
 {
     char *buffer;
+    bool is_stdin_source = ctx->file == stdin;
     size_t buffer_size = 0;
     size_t num_read = 0;
-    size_t remaining_data_size = ctx->chunk_header.sz;
+    size_t remaining_data_size = is_stdin_source ? SIZE_MAX : ctx->file_size;
+    size_t played_data_size = 0;
     size_t read_size = 0;
     const struct pcm_config *config = pcm_get_config(ctx->pcm);
 
@@ -421,15 +473,27 @@ int play_sample(struct ctx *ctx)
         read_size = remaining_data_size > buffer_size ? buffer_size : remaining_data_size;
         num_read = fread(buffer, 1, read_size, ctx->file);
         if (num_read > 0) {
-            if (pcm_writei(ctx->pcm, buffer,
-                pcm_bytes_to_frames(ctx->pcm, num_read)) < 0) {
-                fprintf(stderr, "error playing sample\n");
+            int written_frames = pcm_writei(ctx->pcm, buffer,
+                    pcm_bytes_to_frames(ctx->pcm, num_read));
+            if (written_frames < 0) {
+                fprintf(stderr, "error playing sample. %s\n", pcm_get_error(ctx->pcm));
                 break;
             }
-            remaining_data_size -= num_read;
+
+            if (!is_stdin_source) {
+                remaining_data_size -= num_read;
+            }
+            played_data_size += pcm_frames_to_bytes(ctx->pcm, written_frames);
         }
     } while (!close && num_read > 0 && remaining_data_size > 0);
 
+    printf("Played %zu bytes. ", played_data_size);
+    if (is_stdin_source) {
+        printf("\n");
+    } else {
+        printf("Remains %zu bytes.\n", remaining_data_size);
+    }
+
     pcm_wait(ctx->pcm, -1);
 
     free(buffer);
diff --git a/utils/tinywavinfo.c b/utils/tinywavinfo.c
index a74ca7d..301f8dc 100644
--- a/utils/tinywavinfo.c
+++ b/utils/tinywavinfo.c
@@ -185,7 +185,7 @@ void analyse_sample(FILE *file, unsigned int channels, unsigned int bits,
         if (num_read > 0) {
             if (2 == bytes_per_sample) {
                 short *buffer_ptr = (short *)buffer;
-                for (i = 0; i < num_read; i += channels) {
+                for (i = 0; i < num_read / bytes_per_sample; i += channels) {
                     for (ch = 0; ch < channels; ch++) {
                         int temp = *buffer_ptr++;
                         /* Signal Normalization */
@@ -196,7 +196,7 @@ void analyse_sample(FILE *file, unsigned int channels, unsigned int bits,
             }
             if (4 == bytes_per_sample) {
                 int *buffer_ptr = (int *)buffer;
-                for (i = 0; i < num_read; i += channels) {
+                for (i = 0; i < num_read / bytes_per_sample; i += channels) {
                     for (ch = 0; ch < channels; ch++) {
                         int temp = *buffer_ptr++;
                         /* Signal Normalization */
-- 
2.34.1

